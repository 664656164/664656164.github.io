<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的技术与生活——c++竞赛 | 欢迎来到小韩的学习博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/shortcut-icon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/public.css" />
  <link rel="stylesheet" href="/css/layout.css" />
  <link rel="stylesheet" href="/css/iconfont.css" />
  <link rel="stylesheet" href="/css/APlayer.min.css" />
  <script src="/js/APlayer.min.js"></script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.pjax.min.js"></script>

  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>
    document.title = `我的技术与生活——c++竞赛`
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  .gray {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 9999;
    display: none;
    pointer-events: none;
    background-color: #000;
    mix-blend-mode: color;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div>
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="http://example.com/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"学习javaweb基础","cover":"/images/javaweb-cover.jpg","path":"2024/03/27/JAVA WEB/"},{"title":"c++竞赛","cover":"/images/c++.jpg","path":"2023/03/27/ACM暑假集训笔记/"},{"title":"学习javaweb框架","cover":"/images/javaweb-cover.jpg","path":"2024/11/27/JAVAWEB框架/"},{"title":"python应用","cover":"/images/python.jpg","path":"2024/04/03/Python/"},{"title":"Redis基础篇","cover":"/images/redis-cover.jpg","path":"2025/03/10/Redis基础篇/"},{"title":"学习git指令","cover":"/images/git.jpg","path":"2024/04/11/git项目管理工具/"},{"title":"Redis实战篇","cover":"/images/redis-cover.jpg","path":"2025/03/31/Redis实战篇/"},{"title":"python基础","cover":"/images/python.jpg","path":"2024/05/12/python详细版本/"},{"title":"微信小程序","cover":"/images/wx.jpg","path":"2024/09/09/微信小程序/"},{"title":"mysql","cover":"/images/mysql.jpg","path":"2023/10/25/数据库知识/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">gcbsh</p>
        <div class="main-left--tags">
          <span class="main-left--tag">减肥</span>
          <span class="main-left--tag">学习</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“关关难过关关过，前路漫漫亦灿灿”</p>
        <p>“愿望是宅家睡大觉”</p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a target="_blank" rel="noopener" href="https://github.com/664656164"><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>7</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>0</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>8 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/link">
            <span class="header-menu--span">友情链接</span>
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>10 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>4天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v1.0.2</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <link rel="stylesheet" href="/css/partial/article.css" />

<div class="article-container">
  <div class="article">
    <h1 class="article-title">c++竞赛</h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            <a class="category-link" href="/categories/c/">C++</a>
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            
          </div>
          
          <p class="article-info--date">日期：2023-03-27 00:00:00</p>
        </div>
        <img src="/images/c++.jpg" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content markdown-body">
      <h1 id="小韩算法笔记"><a href="#小韩算法笔记" class="headerlink" title="小韩算法笔记"></a>小韩算法笔记</h1><h1 id="auto遍历"><a href="#auto遍历" class="headerlink" title="auto遍历"></a>auto遍历</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it:se) cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>



<h1 id="find函数"><a href="#find函数" class="headerlink" title="find函数"></a>find函数</h1><p><img src="/images/image-20230829163812428.png" alt="c++算法图"></p>
<p><img src="/images/image-20230829163837964.png" alt="c++算法图"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p2; i++) <span class="comment">//找v1中 v0有 v2无的元素</span></span><br><span class="line">      </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">find</span>(v<span class="number">0.</span><span class="built_in">begin</span>(), v<span class="number">0.</span><span class="built_in">end</span>(), v1[i]) != v<span class="number">0.</span><span class="built_in">end</span>())<span class="comment">//在v0中存在元素v1[i]，就返回找到该元素的地址</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">find</span>(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), v1[i]) == v<span class="number">2.</span><span class="built_in">end</span>())<span class="comment">//在v2中不存在元素v1[i]，就返回尾巴地址</span></span><br><span class="line">				v<span class="number">3.</span><span class="built_in">push_back</span>(v1[i]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="1-vector-动态数组-成倍增长"><a href="#1-vector-动态数组-成倍增长" class="headerlink" title="1.vector(动态数组 成倍增长)"></a>1.vector(动态数组 成倍增长)</h2><p>1.头文件：#include<vector></p>
<p>2.访问方式：数组访问</p>
<p><img src="/images/image-20230716020927113.png" alt="c++算法图"></p>
<h2 id="2-queue-队列-先进先出"><a href="#2-queue-队列-先进先出" class="headerlink" title="2.queue(队列 先进先出)"></a>2.queue(队列 先进先出)</h2><p>1.头文件：#include<queue></p>
<p><img src="/images/image-20230716021033704.png" alt="c++算法图"></p>
<h2 id="3-stack（栈-先进后出）"><a href="#3-stack（栈-先进后出）" class="headerlink" title="3.stack（栈 先进后出）"></a>3.stack（栈 先进后出）</h2><p>1.头文件：#include<stack></p>
<p><img src="/images/image-20230716021134514.png" alt="c++算法图"></p>
<h2 id="4-string-string类"><a href="#4-string-string类" class="headerlink" title="4.string(string类)"></a>4.string(string类)</h2><p>1.头文件：#include<string></p>
<p><img src="/images/image-20230716021322962.png" alt="c++算法图"></p>
<h3 id="注意：getline-cin-s-必须用于string类！！！可以读取空格"><a href="#注意：getline-cin-s-必须用于string类！！！可以读取空格" class="headerlink" title="注意：getline(cin,s)必须用于string类！！！可以读取空格"></a>注意：getline(cin,s)必须用于string类！！！可以读取空格</h3><h2 id="5-set-去重排序"><a href="#5-set-去重排序" class="headerlink" title="5.set(去重排序)"></a>5.set(去重排序)</h2><p>1.头文件：#include<set></p>
<p>2.访问方式：</p>
<p>第一种迭代器访问</p>
<p>eg.set<int>::iterator it;</p>
<p>for(it&#x3D;se.begin();it!&#x3D;se.end();++it) cout&lt;&lt;*it&lt;&lt;” “;</p>
<p>第二种auto访问</p>
<p> for(auto it:se) cout&lt;&lt;it&lt;&lt;” “;</p>
<p><img src="/images/image-20230716022051349.png" alt="c++算法图"></p>
<h2 id="6-map-映射-（键值-–-值-）"><a href="#6-map-映射-（键值-–-值-）" class="headerlink" title="6.map(映射 （键值 –&gt;值)）"></a>6.map(映射 （键值 –&gt;值)）</h2><p>1.头文件：#include<map></p>
<p>2.访问方式：迭代器访问</p>
<p>map&lt;string,int&gt; ma;</p>
<p>eg.map&lt;string,int&gt;::iterator it;</p>
<p>for(it&#x3D;ma.begin();it!&#x3D;ma.end();++it) …</p>
<p><img src="/images/image-20230716022805009.png" alt="c++算法图"></p>
<h2 id="7-pair-一对-队组"><a href="#7-pair-一对-队组" class="headerlink" title="7.pair(一对&#x2F;队组)"></a>7.pair(一对&#x2F;队组)</h2><p>1.头文件：#include<utility></p>
<p>2.访问方式：p.first(第一个元素) 怕。second(第二个元素)</p>
<p>typedef pai&lt;int,int&gt; pii;</p>
<h2 id="8-priority-queue-优先队列"><a href="#8-priority-queue-优先队列" class="headerlink" title="8.priority_queue(优先队列)"></a>8.priority_queue(优先队列)</h2><p>1.头文件：#include<queue></p>
<p>2.命名：priority_queue<int> a;（默认为降序队列）</p>
<p>2.俩种形式：</p>
<p>  升序队列  <code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;</code></p>
<p>  降序队列  <code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;q;</code></p>
<h2 id="9-双端队列"><a href="#9-双端队列" class="headerlink" title="9.双端队列"></a>9.双端队列</h2><ol>
<li><p>双端队列：</p>
</li>
<li><table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>front()</td>
<td>返回队列第一个元素的引用</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用</td>
</tr>
<tr>
<td>push_back()</td>
<td>在队列的尾部添加一个元素</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的元素</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器头部的元素</td>
</tr>
<tr>
<td>empty()</td>
<td>容器中无元素返回true；否则返回false</td>
</tr>
</tbody></table>
<p>3.头文件为#include<deque></p>
</li>
</ol>
<h2 id="10-unordered-map"><a href="#10-unordered-map" class="headerlink" title="10.unordered_map"></a>10.unordered_map</h2><p>1.头文件#include<unordered_map></p>
<p>unordered_map&lt;string,int&gt; u;</p>
<p>2.常见用法：</p>
<p>   插入元素：insert();</p>
<p>   删除元素：erase();</p>
<p>   清空元素：clear();</p>
<p>   判空：empty();</p>
<p>   求元素个数：size();</p>
<p>3.迭代器遍历</p>
<p>第一种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i:map)&#123;</span><br><span class="line">​     string s=i.first;</span><br><span class="line">​     <span class="type">int</span> x=i.second;</span><br><span class="line">​    &#125;</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=u.<span class="built_in">begin</span>();it!=map.<span class="built_in">end</span>();++it)&#123;</span><br><span class="line">    string s=it-&gt;first;</span><br><span class="line">    <span class="type">int</span> x=it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>（一条路走到黑）回溯 剪枝  类似于先序遍历</p>
<h2 id="dfs模板"><a href="#dfs模板" class="headerlink" title="dfs模板"></a>dfs模板</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DFS</span>(dep,....)<span class="comment">//dep代表目前DFS的深度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(找到解||走不下去了)&#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    枚举下一种情况，<span class="built_in">DFS</span>(dep<span class="number">+1.</span>.)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(到达边界)</span><br><span class="line">    &#123;</span><br><span class="line">        相应操作</span><br><span class="line">    &#125;</span><br><span class="line">    尝试每一种可能</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(需要满足的条件)</span><br><span class="line">        &#123;</span><br><span class="line">            标记</span><br><span class="line">            继续下一步<span class="built_in">dfs</span>(num<span class="number">+1</span>)</span><br><span class="line">            恢复初始状态</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-数字全排列"><a href="#1-数字全排列" class="headerlink" title="1.数字全排列"></a>1.数字全排列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span> book[maxn];  <span class="comment">//标记数字得状态 1代表使用 0代表未使用</span></span><br><span class="line"><span class="type">int</span> a[maxn];  <span class="comment">//存储全排</span></span><br><span class="line"><span class="type">int</span> m=<span class="number">1</span>,n;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> m)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(m==n<span class="number">+1</span>)&#123;  <span class="comment">//为什么m要等于n+1得时候打印出来全排？假如n=3，m=3得时候其实只有俩层放了数字，m=2嘛，然后加1，变3，实际只填了2层就结束了。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">        cout&lt;&lt;endl;  </span><br><span class="line">        <span class="keyword">return</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;  <span class="comment">//第一轮：dfs(5)-&gt;1 2 3 4-&gt;返回四 book[4]=0;i=4结束for循环-&gt;返回三-&gt;book[3]=0; i=4;a[3]=4;book[4]=1;dfs(4);-&gt;四a[4]=4;book[4]=1;dfs(5);输出 1 2 4 3</span></span><br><span class="line">        <span class="keyword">if</span>(book[i]==<span class="number">0</span>)&#123;  </span><br><span class="line">            a[m]=i;  </span><br><span class="line">            book[i]=<span class="number">1</span>;  </span><br><span class="line">            <span class="built_in">dfs</span>(m<span class="number">+1</span>); <span class="comment">//dfs返回这里 </span></span><br><span class="line">            book[i]=<span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    cin&gt;&gt;n;  </span><br><span class="line">    <span class="built_in">dfs</span>(m);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全排数字：eg 全排4</p>
<p>第一层dfs   book[1]&#x3D;1; a[1]&#x3D;1;</p>
<p>第二层dfs  book[2]&#x3D;1;a[2]&#x3D;2;</p>
<p>第三层dfs  book[3]&#x3D;1;a[3]&#x3D;3;</p>
<p>第四层dfs  book[4]&#x3D;1;a[4]&#x3D;4;</p>
<p>第五层dfs  输出1 2 3 4，return ;</p>
<p>返回第四层dfs(第五层完毕，回4) i&#x3D;4；book[4]&#x3D;0;</p>
<p>返回第三层dfs(第四层完毕，回3) i&#x3D;3;book[3]&#x3D;0;i&#x3D;4;a[3]&#x3D;4;book[4]&#x3D;1;dfs(4);</p>
<p>第四层dfs a[4]&#x3D;3;book[3]&#x3D;1;dfs(5);</p>
<p>第五层dfs  输出1 2 ,4,3 return ;</p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>广撒网 类似于层次遍历</p>
<p><img src="/images/image-20230711172309330.png" alt="c++算法图"></p>
<h2 id="BFS模板-优先队列"><a href="#BFS模板-优先队列" class="headerlink" title="BFS模板(优先队列)"></a>BFS模板(优先队列)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> s)</span>    <span class="comment">//此处参数类型可变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;  <span class="comment">//定义空队列</span></span><br><span class="line">	q.<span class="built_in">push</span>(s);  <span class="comment">//将起点入队</span></span><br><span class="line">	<span class="comment">//将起点s标记</span></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		 q.<span class="built_in">front</span>() <span class="comment">//访问队首元素 </span></span><br><span class="line">		 q.<span class="built_in">pop</span>() <span class="comment">//队首元素出队 		  		if(队首元素为目标状态)&#123;</span></span><br><span class="line">		      <span class="comment">//根据题意对应操作</span></span><br><span class="line">		&#125;</span><br><span class="line">	         <span class="comment">//遍历与队首元素相邻的未访问元素                      //逐个入队并标记为已访问	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二分法与折半枚举"><a href="#二分法与折半枚举" class="headerlink" title="二分法与折半枚举"></a>二分法与折半枚举</h1><h2 id="1-二分法（必须争对有序序列）"><a href="#1-二分法（必须争对有序序列）" class="headerlink" title="1.二分法（必须争对有序序列）"></a>1.二分法（必须争对有序序列）</h2><h2 id="一-二分查找-lower-bound-upper-bound-，binary-search"><a href="#一-二分查找-lower-bound-upper-bound-，binary-search" class="headerlink" title="一.二分查找(lower_bound(), upper_bound()，binary_search())"></a>一.二分查找(lower_bound(), upper_bound()，binary_search())</h2><p><code>binary_search</code>  寻找在一个单调序列[first,last)中等于value的元素的下标,如果没找到对应值，就返回一个负数</p>
<p><code>lower_bound</code>  寻找在一个单调序列[first,last)中第一个大于等于value的元素的下标,如果没找到对应值，就返回最后一个元素的位置</p>
<p><code>upper_bound </code>   寻找在一个单调序列[first,last)中第一个大于value的元素的下标,如果没找到对应值，就返回最后一个元素的位置</p>
<h2 id="二-每日小技巧"><a href="#二-每日小技巧" class="headerlink" title="二.每日小技巧"></a>二.每日小技巧</h2><h5 id="1-sort默认排序为less（从小到大），要想实现从大到小："><a href="#1-sort默认排序为less（从小到大），要想实现从大到小：" class="headerlink" title="1.sort默认排序为less（从小到大），要想实现从大到小："></a>1.sort默认排序为less（从小到大），要想实现从大到小：</h5><p>1.自写cmp;</p>
<p>2.sort(a+1,a+n+1,greater<int>());&#96;</p>
<h5 id="2-Π-3-1416…-acos-1-0"><a href="#2-Π-3-1416…-acos-1-0" class="headerlink" title="2.Π&#x3D;3.1416…..&#x3D;acos(-1.0);"></a>2.Π&#x3D;3.1416…..&#x3D;acos(-1.0);</h5><h5 id="三-二分查值-最大化最小值、最小化最大值"><a href="#三-二分查值-最大化最小值、最小化最大值" class="headerlink" title="三.二分查值(最大化最小值、最小化最大值)"></a>三.二分查值(最大化最小值、最小化最大值)</h5><p>二分法在一段区间内快速找到符合给定条件的最大值或是最小值.</p>
<p>1.最大化最小值</p>
<p>解释：求解一个满足条件的答案x,x值域为有限的[l,r],当x很小的时候都是符合条件的,我们需要求满足条件的最大的x</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">c</span><span class="params">(<span class="type">double</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断答案为mid时是否满足条件,满足返回true,否则false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> l=<span class="number">0</span>,r=maxa,mid;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;<span class="number">0.001</span>)&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">c</span>(mid)) l=mid; </span><br><span class="line">		<span class="keyword">else</span> r=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.最小化最大值</p>
<p>解释：求解一个满足条件的答案x,x值域为有限的[l,r],当x很大的时候都是符合条件的,我们需要求满足条件的最小的x.</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">c</span><span class="params">(<span class="type">double</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断答案为mid时是否满足条件,满足返回true,否则false</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">double</span> l=<span class="number">0</span>,r=maxa,mid;</span><br><span class="line">	<span class="keyword">while</span>(r-l&gt;<span class="number">0.001</span>)&#123;</span><br><span class="line">		mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">c</span>(mid)) r=mid; </span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="单调栈与单调队列"><a href="#单调栈与单调队列" class="headerlink" title="单调栈与单调队列"></a>单调栈与单调队列</h1><h2 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1.单调栈"></a>1.单调栈</h2><ol>
<li><p>栈的特点：先进后出（洗碟子，先洗的放在下面，用的时候最后拿出来）</p>
</li>
<li><p>单调栈：</p>
<p>单调递增栈：（从小到大）维护最小值</p>
<p>单调递减栈：（从大到小） 维护最大值</p>
</li>
<li><p>数组模拟单调栈代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">2 3 5 1 7 9</span></span><br><span class="line"><span class="comment">单调递减 9</span></span><br><span class="line"><span class="comment">单调递增 1 7 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> b[maxn],a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">	<span class="comment">//单调递减 </span></span><br><span class="line">	<span class="keyword">while</span>(top!=<span class="number">0</span>&amp;&amp;b[top<span class="number">-1</span>]&gt;=a[i]) top--;</span><br><span class="line">	<span class="comment">//单调递减增 </span></span><br><span class="line">	<span class="comment">//	while(top!=0&amp;&amp;b[top-1]&lt;=a[i]) top--;</span></span><br><span class="line">		b[top++]=a[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;top;++i) cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>4.用栈来表示单调栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		<span class="comment">//递增 </span></span><br><span class="line"><span class="comment">//		while(s.size()!=0&amp;&amp;x&gt;=s.top()) s.pop(); </span></span><br><span class="line"><span class="comment">//		s.push(x); </span></span><br><span class="line">		<span class="comment">//递减 </span></span><br><span class="line">		<span class="keyword">while</span>(s.<span class="built_in">size</span>()!=<span class="number">0</span>&amp;&amp;x&lt;=s.<span class="built_in">top</span>()) s.<span class="built_in">pop</span>(); </span><br><span class="line">		s.<span class="built_in">push</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">		cout&lt;&lt;s.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		s.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.ppt上面例题</p>
<p>&#96;&#96;*<em>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</em><code> </code><em>输入格式</em><code> </code><em>第一行包含整数 N，表示数列长度。</em>&#96;</p>
<p><code>*第二行包含 N 个整数，表示整数数列。*</code></p>
<p><code>*输出格式*</code><br><code>*共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。*</code></p>
<p><code>*样例一:*</code></p>
<p><code>*5*</code><br><code>*3 4 2 7 5*</code><br><code>*输出:*</code><br><code>*-1 3 -1 2 2*</code></p>
<p><code>*样例二:*</code><br><code>*10*</code><br><code>*11 27 11 6 14 26 8 22 13 7*</code><br><code>*输出:*</code></p>
<p><code>-1 11 11 -1 6 14 6 8 8 6*</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">3 4 2 7 5</span></span><br><span class="line"><span class="comment">-1 3 -1 2 2</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">11 27 11 6 14 26 8 22 13 7</span></span><br><span class="line"><span class="comment">-1 11 11 -1 6 14 6 8 8 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">while</span>(top!=<span class="number">0</span>&amp;&amp;a[i]&lt;b[top<span class="number">-1</span>]) top--;</span><br><span class="line">		<span class="keyword">if</span>(top==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cout&lt;&lt;b[top<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		b[top++]=a[i];		</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-单调队列"><a href="#2-单调队列" class="headerlink" title="2.单调队列"></a>2.单调队列</h2><p>1.队列的特点：先进先出（排队）</p>
<p>2.双端队列：</p>
</li>
<li><table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>front()</td>
<td>返回队列第一个元素的引用</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素的引用</td>
</tr>
<tr>
<td>push_back()</td>
<td>在队列的尾部添加一个元素</td>
</tr>
<tr>
<td>pop_back()</td>
<td>移除容器尾部的元素</td>
</tr>
<tr>
<td>pop_front()</td>
<td>移除容器头部的元素</td>
</tr>
<tr>
<td>empty()</td>
<td>容器中无元素返回true；否则返回false</td>
</tr>
</tbody></table>
<p>3.头文件为#include<deque></p>
<p>4.单调队列：</p>
<p>单调递增队列：（从小到大）维护最小值</p>
<p>单调递减队列：（从大到小） 维护最大值</p>
<p>5.数组模拟单调队列代码：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">3 2 8 4 5 7 6 4</span></span><br><span class="line"><span class="comment">递增队列：2 4</span></span><br><span class="line"><span class="comment">递减队列：8 7 6 4 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="comment">//递减 </span></span><br><span class="line">		<span class="comment">//while(l!=r&amp;&amp;a[i]&gt;=b[r-1]) r--;</span></span><br><span class="line">		<span class="comment">//递增</span></span><br><span class="line">		<span class="keyword">while</span>(l!=r&amp;&amp;a[i]&lt;=b[r<span class="number">-1</span>]) r--;</span><br><span class="line">		b[r++]=a[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;r;++i) cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.用双端栈来表示单调队列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	8</span></span><br><span class="line"><span class="comment">    3 2 8 4 5 7 6 4</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="comment">//单调递增 </span></span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()!=<span class="number">0</span>&amp;&amp;q.<span class="built_in">back</span>()&gt;=x) q.<span class="built_in">pop_back</span>();</span><br><span class="line">	q.<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">		cout&lt;&lt;q.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">		q.<span class="built_in">pop_front</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><h2 id="1-巴什博弈"><a href="#1-巴什博弈" class="headerlink" title="1.巴什博弈"></a>1.巴什博弈</h2><ol>
<li><p>描述：从m个石头中取(1~n)个石头，最后取完为胜利家。</p>
</li>
<li><p>公式：<code>m=k*(n+1)+r;</code></p>
</li>
<li><p>if(m%(n+1)) 先手赢</p>
<p>else 后手赢</p>
</li>
</ol>
<p><code>为什么捏？because:当m%(n+1)有余数为r得时候嘛，先手可以先选r个石头，然后后手只能选1~n个石头，后手选完x个，先手只需选n+1-x个。不断构造n+1.肯定就是聪明得先手小盆友赢啦！</code></p>
<p>4.例题：oj Brave Game</p>
<p><img src="/images/image-20230716130554218.png" alt="c++算法图"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">if</span>(n%(m<span class="number">+1</span>)) cout&lt;&lt;<span class="string">&quot;first&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;second&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-威佐夫博弈"><a href="#2-威佐夫博弈" class="headerlink" title="2.威佐夫博弈"></a>2.威佐夫博弈</h2><ol>
<li><p>描述：2堆  1.2堆取同样多 2.任意取一堆  最后取完者赢。</p>
</li>
<li><p>公式：ans&#x3D;abs(b-a)*<code>((sqrt(5.0)+1.0)/2.0)</code>黄金分割</p>
</li>
<li><p>if(min(a,b)&#x3D;&#x3D;ans) 后手赢</p>
<p>else 先手赢</p>
</li>
<li><p>代码展示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;m) <span class="built_in">swap</span>(n,m);<span class="comment">//swap只交换值 所以n始终表示最小得那个数</span></span><br><span class="line">		<span class="type">int</span> ans=(m-n)*(<span class="number">1</span>+<span class="built_in">sqrt</span>(<span class="number">5.0</span>))/<span class="number">2.0</span>;</span><br><span class="line">		<span class="keyword">if</span>(ans==n) cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;<span class="comment">//1表示先手赢 0表示后手赢</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-尼姆博弈"><a href="#3-尼姆博弈" class="headerlink" title="3.尼姆博弈"></a>3.尼姆博弈</h2><ol>
<li><p>描述：n堆取任意，最后取完者赢。</p>
</li>
<li><p>公式：每一堆异或一下，为0就后手赢，否则先手赢</p>
</li>
<li><p>补充知识：异或，相同为0，不同为1.</p>
<p><img src="/images/image-20230716184058481.png" alt="c++算法图"></p>
<p><img src="/images/image-20230716184010175.png" alt="c++算法图"></p>
</li>
</ol>
<h2 id="4-斐波那契博弈"><a href="#4-斐波那契博弈" class="headerlink" title="4.斐波那契博弈"></a>4.斐波那契博弈</h2><p>有一堆数量为n的石子，游戏双方轮流取，满足下面条件：<br>       1.先手第一次不能把石头取完。<br>       2.之后每次取的石头在上次对手取的石头的两倍之内，不能不取，例如上次对手取10个石子，则此时可取从1到20之间（包括1和20）                 		的任意数目石子。取走最后一个石头的人就是赢家。</p>
<p><img src="/images/image-20230716184316524.png" alt="c++算法图"></p>
<h1 id="一周小知识点查缺"><a href="#一周小知识点查缺" class="headerlink" title="一周小知识点查缺"></a>一周小知识点查缺</h1><ol>
<li><p>map初始化为0，当要做标记时，不能用0来标记！！！</p>
</li>
<li><p>sort默认排序为less（从小到大），要想实现从大到小：自写cmp;  </p>
<h5 id="sort-a-1-a-n-1-greater"><a href="#sort-a-1-a-n-1-greater" class="headerlink" title="sort(a+1,a+n+1,greater&lt;int&gt;());"></a><code>sort(a+1,a+n+1,greater&lt;int&gt;());</code></h5></li>
<li><p>Π&#x3D;3.1416…..&#x3D;acos(-1.0);</p>
</li>
<li><p>注意：getline(cin,s)必须用于string类！！！可以读取空格</p>
</li>
<li><p>异或，相同为0，不同为1.</p>
</li>
</ol>
<h1 id="第二周笔记"><a href="#第二周笔记" class="headerlink" title="第二周笔记"></a>第二周笔记</h1><h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><h2 id="一-建树："><a href="#一-建树：" class="headerlink" title="一.建树："></a>一.建树：</h2><p>二维数组trie<code>[maxn][26]``trie[根节点][根节点所连子节点],</code>0表示没建立，1表示建立。根节点从0开始建树；然后建的每个结点的映射都是不同的（用全局变量idx++来映射）；</p>
<p>​              1.从根节点开始建立，扫描单词</p>
<p>​              2.判断这个结点建立了没有，如果没建立就建立。</p>
<p>​              3.走向下一个子节点，把它作为根结点。</p>
<p>​              4.标记单词末尾，记录完整单词。</p>
<p>代码模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;<span class="comment">//根结点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="type">int</span> j=x[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(!trie[p][j]) trie[p][j]=++idx;<span class="comment">//判断此结点建立没有，没建立就建立</span></span><br><span class="line">		p=trie[p][j];<span class="comment">//都要走向下一个子节点，此时下一个子节点就为根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p]++;<span class="comment">//标记这个字符串出现的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：idx要前加加</p>
<p>​           如果idx++的话，第一个字母进来的时候，trie[][]还是为0，就会影响下个结点的判断，建不建立。</p>
<h2 id="二-查找："><a href="#二-查找：" class="headerlink" title="二.查找："></a>二.查找：</h2><p>从根节点开始查，如果查到的有一个字母对应结点没有建立，那么该单词就没有，个数为0；</p>
<p>​             1.从根节点开始查，扫描单词</p>
<p>​              2.有字母s[i]（该结点建立了），则走下去，走到下一个子结点，能走到词尾，返回插入次数；无字母（该结点没建立），接   直接返回0；</p>
<p>  代码模板： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=<span class="number">0</span>;<span class="comment">//从根结点开始查</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">		<span class="type">int</span> j=x[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(trie[p][j]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查到中途，一个字母没建立，说明该树里面都没有这个单词，就返回个数为0；</span></span><br><span class="line">		p=trie[p][j];<span class="comment">//查向下一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];<span class="comment">//返回该单词个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><p>(差分是前缀和的逆运算)</p>
<h2 id="一-一维前缀和"><a href="#一-一维前缀和" class="headerlink" title="一.一维前缀和"></a>一.一维前缀和</h2><p>1.前缀和：sum[i]&#x3D;sum[i-1]+a[i];</p>
<p>2.注意下标从1开始；</p>
<p>3.求l到r的区间和：cnt&#x3D;sum[r]-sum[l-1];</p>
<h2 id="二-二维前缀和"><a href="#二-二维前缀和" class="headerlink" title="二.二维前缀和"></a>二.二维前缀和</h2><h3 id="1-sum-i-j-的定义："><a href="#1-sum-i-j-的定义：" class="headerlink" title="1.sum[i][j]的定义："></a>1.<code>sum[i][j]</code>的定义：</h3><p>​     i,j这个点所包含左上方区域的和。</p>
<p><img src="/images/image-20230722133400763.png" alt="c++算法图"></p>
<h3 id="2-如何构造每一个点的前缀和（sum-i-j-）"><a href="#2-如何构造每一个点的前缀和（sum-i-j-）" class="headerlink" title="2.如何构造每一个点的前缀和（sum[i][j]）?"></a>2.如何构造每一个点的前缀和（<code>sum[i][j]</code>）?</h3><p><img src="/images/image-20230718142913220.png" alt="c++算法图"></p>
<h3 id="3-如何求点（x1-y1-到（x2-y2-之间区域的前缀和呢？"><a href="#3-如何求点（x1-y1-到（x2-y2-之间区域的前缀和呢？" class="headerlink" title="3.如何求点（x1,y1)到（x2,y2)之间区域的前缀和呢？"></a>3.如何求点（x1,y1)到（x2,y2)之间区域的前缀和呢？</h3><p>第一步：先求出每个点的前缀和。</p>
<p>第二步：ans&#x3D;<code>sum[x2][y2]-sum[x2][y1-1]-sum[x1-1][y2]+sum[x1-1][y1-1];</code></p>
<p><img src="/images/image-20230722132733746.png" alt="c++算法图"></p>
<h2 id="三-一维差分"><a href="#三-一维差分" class="headerlink" title="三.一维差分"></a>三.一维差分</h2><h3 id="1-差分数组-pre-i-a-i-a-i-1"><a href="#1-差分数组-pre-i-a-i-a-i-1" class="headerlink" title="1.差分数组  pre[i]&#x3D;a[i]-a[i-1];"></a>1.差分数组  pre[i]&#x3D;a[i]-a[i-1];</h3><p>  eg.sum 1  3   7    5    2     6</p>
<p>​       pre    1   2   4   -2   -3   4</p>
<h3 id="2-假定要在l，r区间都加上x-对于操作-l-r-x-即pre-l-x-pre-r-1-x"><a href="#2-假定要在l，r区间都加上x-对于操作-l-r-x-即pre-l-x-pre-r-1-x" class="headerlink" title="2.假定要在l，r区间都加上x,对于操作[l,r]+x;即pre[l]+x,pre[r+1]-x;"></a>2.假定要在l，r区间都加上x,对于操作[l,r]+x;即pre[l]+x,pre[r+1]-x;</h3><p>解析：因为对差分数组pre[l]上加减一个数，再求前缀和时，对l以及l后面的每一个数都会加减上这个数，但是我们只加到r嘛，所以r后面的数被加减上的我们需要还原，就减加上就好啦。</p>
<p>图解：</p>
<p> <img src="/images/image-20230718113149501.png" alt="c++算法图"></p>
<p>eg l&#x3D;1,r&#x3D;3 x&#x3D;3;</p>
<p>第一步：构造差分数组：pre[i]&#x3D;a[i]-a[i-1];</p>
<p>​       sum <code>1  3   7</code>    5    2     6</p>
<p>​       pre    1   2   4   -2   -3   4</p>
<p>​      第二步：pre[l]+&#x3D;3,pre[r+1]-&#x3D;3; —&gt;pre   4 2 4 -5 -3 4</p>
<p>​      第三步求前缀和还原：<code>4 6 10</code> 5 2 6</p>
<p>​      相较于原来l到r区间就都加了x啦！</p>
<h2 id="四-二维差分"><a href="#四-二维差分" class="headerlink" title="四.二维差分"></a>四.二维差分</h2><h3 id="1-a-数组是b-数组的前缀和数组，那么b-是a-的差分数组"><a href="#1-a-数组是b-数组的前缀和数组，那么b-是a-的差分数组" class="headerlink" title="1.a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组"></a>1.<code>a[][]数组</code>是<code>b[][]数组</code>的前缀和数组，那么b[][]是a[][]的差分数组</h3><p>那么<code>a[i][j]</code>是b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和。</p>
<h3 id="2-深刻理解b数组是a数组的差分数组："><a href="#2-深刻理解b数组是a数组的差分数组：" class="headerlink" title="2.深刻理解b数组是a数组的差分数组："></a>2.深刻理解b数组是a数组的差分数组：</h3><p>​    也就是说我们对<code>b[i][j]</code>进行操作时都会影响<code>a[i][j]</code>已及它后面的每一数；</p>
<h3 id="3-那么如何构造a数组的差分数组捏？"><a href="#3-那么如何构造a数组的差分数组捏？" class="headerlink" title="3.那么如何构造a数组的差分数组捏？"></a>3.那么如何构造a数组的差分数组捏？</h3><p>已知原数组a中被选中的子矩阵为 以(x1,y1)为左上角，以(x2,y2)为右下角所围成的矩形区域;</p>
<p><img src="/images/image-20230718104005096.png" alt="c++算法图"></p>
<p>我们可以先假想a数组为空，那么b数组一开始也为空，但是实际上a数组并不为空，因此我们每次让b数组以(i,j)为左上角到以(i,j)为右下角面积内元素(其实就是一个小方格的面积)去插入 c&#x3D;a<code>[i][j]</code>，等价于原数组a中(i,j) 到(i,j)范围内 加上了 <code>a[i][j] ,</code>因此执行n*m次插入操作，就成功构建了差分b数组.</p>
<p>4.板子例题</p>
<p><img src="/images/image-20230718104838064.png" alt="c++算法图">原数组：1 2 2 1               ——&gt;差分数组：1 1 0 -1<br>                3 2 2 1                                           2 -2 0 0<br>                1 1 1 1                                           -2 1 0 1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];<span class="comment">//a为差分数组，s为前缀和数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);<span class="comment">//原来的数组就是a的前缀和数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            a[i][j] = s[i][j] - s[i - <span class="number">1</span>][j] - s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c);</span><br><span class="line">        a[x1][y1] += c;</span><br><span class="line">        a[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">        a[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">        a[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            s[i][j] = a[i][j] + s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i][j]);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线段树和线段数组"><a href="#线段树和线段数组" class="headerlink" title="线段树和线段数组"></a>线段树和线段数组</h1><h2 id="一-线段数组"><a href="#一-线段数组" class="headerlink" title="一.线段数组"></a>一.线段数组</h2><h3 id="1-思想："><a href="#1-思想：" class="headerlink" title="1.思想："></a>1.思想：</h3><p><img src="/images/image-20230722125216554.png" alt="c++算法图"></p>
<p><strong>注意：tre</strong>数组并不是a数组的前缀和。**<br>        tre数组：二次幂数组是求前缀和，而非二次幂的偶数是计算部分前缀和。**<br>eg: find(4):意思就是找1到4的所有元素和！sum&#x3D;tre[4]&#x3D;a4+a3+a2+a1;     4的二进制：0100，减去一个最后一个1的位置捏，变成了0000，find函数中循环结束。<br>eg:find(6):意思就是找1到6的所有元素和！sum&#x3D;tre[6]+tre[4]&#x3D;a6+a5+a4+a3+a2+a1;   6的二进制：0110，减去一个最后一个1捏，变成了0100-&gt;4,再变成0000结束。所以sum&#x3D;tre[6]+tre[4];</p>
<h3 id="2-lowbit函数（求最后一个1的位置）"><a href="#2-lowbit函数（求最后一个1的位置）" class="headerlink" title="2.lowbit函数（求最后一个1的位置）"></a>2.lowbit函数（求最后一个1的位置）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-增加："><a href="#3-增加：" class="headerlink" title="3.增加："></a>3.增加：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//在i位置加上x</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=m;k+=<span class="built_in">lowbit</span>(k))t[k]+=x;<span class="comment">//m个数/序列大小</span></span><br><span class="line">&#125;<span class="comment">//eg.如果在2位置加上6，2的2进制为0010，t[2]+=6，不仅仅只有t[2],要增加，由上面的思想图可知，t[4],t[8]..也要增加，所以k要不断的加上lowbit(k)它自己本身的最后一个1位置，不断往上找。让所有包含的都要加上。</span></span><br></pre></td></tr></table></figure>

<h3 id="4-查找："><a href="#4-查找：" class="headerlink" title="4.查找："></a>4.查找：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i;k&gt;=<span class="number">1</span>;k-=<span class="built_in">lowbit</span>(k))sum+=t[k];  </span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;<span class="comment">//find(6):意思就是找1到6的所有元素和！sum=tre[6]+tre[4],6的二进制：0110，减去一个最后一个1捏，变成了0100-&gt;4,再变成0000结束。所以sum=tre[6]+tre[4];</span></span><br></pre></td></tr></table></figure>



<h2 id="二-线段树"><a href="#二-线段树" class="headerlink" title="二,.线段树"></a>二,.线段树</h2><h3 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1.结构体"></a>1.结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">xiaohan</span>&#123;</span><br><span class="line">	<span class="type">int</span> sum;<span class="comment">//权值</span></span><br><span class="line">	<span class="type">int</span> l;<span class="comment">//左孩子</span></span><br><span class="line">	<span class="type">int</span> r;<span class="comment">//右孩子</span></span><br><span class="line">&#125;tree[maxn];<span class="comment">//此时这里的a[i]的i代表父亲节点</span></span><br></pre></td></tr></table></figure>

<h3 id="2-建树"><a href="#2-建树" class="headerlink" title="2.建树"></a>2.建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">oid <span class="title">build</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//递归建树   父亲结点 左孩子 右孩子 </span></span><br><span class="line">	tree[i].l=l;</span><br><span class="line">	tree[i].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;<span class="comment">//为叶子结点</span></span><br><span class="line">		tree[i].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(i*<span class="number">2</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(i*<span class="number">2</span><span class="number">+1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">	tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span><span class="number">+1</span>].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//找l到r的和</span></span><br><span class="line">	<span class="keyword">if</span>(tree[i].l&gt;=l&amp;&amp;tree[i].r&lt;=r)<span class="comment">//如果这个区间被完全包括在目标区间里面，直接返回这个区间的值</span></span><br><span class="line">		<span class="keyword">return</span> tree[i].sum;</span><br><span class="line">	<span class="keyword">if</span>(tree[i].r&lt;l||tree[i].l&lt;r)<span class="comment">//如果这个区间和目标区间毫不相干，返回0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(tree[i*<span class="number">2</span>].r&gt;=l)  s+=<span class="built_in">find</span>(i*<span class="number">2</span>,l,r);<span class="comment">//如果这个区间的左儿子和目标区间又交集，那么搜索左儿子</span></span><br><span class="line">	<span class="keyword">if</span>(tree[i*<span class="number">2</span><span class="number">+1</span>].l&lt;=r)  s+=<span class="built_in">find</span>(i*<span class="number">2</span><span class="number">+1</span>,l,r);<span class="comment">//如果这个区间的右儿子和目标区间又交集，那么搜索右儿子</span></span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-单点修改区间"><a href="#4-单点修改区间" class="headerlink" title="4.单点修改区间"></a>4.单点修改区间</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> dis,<span class="type">int</span> k)</span></span>&#123;<span class="comment">//单点修改区间 在dis位置+k</span></span><br><span class="line">	<span class="keyword">if</span>(tree[i].l==tree[i].r)&#123;<span class="comment">//如果是叶子节点，那么说明找到了</span></span><br><span class="line">		tree[i].sum+=k;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dis&lt;=tree[i*<span class="number">2</span>].r)  <span class="built_in">add</span>(i*<span class="number">2</span>,dis,k);<span class="comment">//在哪往哪跑</span></span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">add</span>(i*<span class="number">2</span><span class="number">+1</span>,dis,k);</span><br><span class="line">	tree[i].sum=tree[i*<span class="number">2</span>].sum+tree[i*<span class="number">2</span><span class="number">+1</span>].sum;<span class="comment">//返回更新</span></span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="并查集和加权并查集"><a href="#并查集和加权并查集" class="headerlink" title="并查集和加权并查集"></a>并查集和加权并查集</h1><h2 id="一-并查集："><a href="#一-并查集：" class="headerlink" title="一.并查集："></a>一.并查集：</h2><h3 id="1-初始化函数（一点不能漏掉）"><a href="#1-初始化函数（一点不能漏掉）" class="headerlink" title="1.初始化函数（一点不能漏掉）"></a>1.初始化函数（一点不能漏掉）</h3><p>刚开始：自己的父亲就是自己</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">innt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-查找函数"><a href="#2-查找函数" class="headerlink" title="2.查找函数"></a>2.查找函数</h3><p>是否在一个集合里面，也就是找根结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-合并函数"><a href="#3-合并函数" class="headerlink" title="3.合并函数"></a>3.合并函数</h3><p>将俩个集合合并在一起，也就是说根节点连在一起。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);<span class="comment">//找到x点的根节点</span></span><br><span class="line">    y=<span class="built_in">find</span>(y);<span class="comment">//找到y结点的根节点</span></span><br><span class="line">    fa[x]=y;<span class="comment">//把x连在y的父节点上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-加权并查集"><a href="#二-加权并查集" class="headerlink" title="二.加权并查集"></a>二.加权并查集</h2><p>在并查集的边上<strong>定义某种权值</strong> ( 一般定义 <strong>点到祖宗的距离</strong> ) 、以及这种权值在路径压缩时产生的运 算.</p>
<p>dis【】数组记录到根节点得距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(x != fa[x]) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> t = fa[x];<span class="comment">//将x的父亲临时保存 </span></span><br><span class="line">        fa[x] = <span class="built_in">find</span>(fa[x]);<span class="comment">//这是x的父亲已经变为祖宗 </span></span><br><span class="line">        dis[x] += dis[t];<span class="comment">//x原父亲t的距离已经变为到祖宗的距离，x到原父亲距离+原父亲到 祖宗距离 = x到祖宗距离 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20230722223213521.png" alt="c++算法图"></p>
<h1 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h1><h2 id="一-哈夫曼树"><a href="#一-哈夫曼树" class="headerlink" title="一.哈夫曼树"></a>一.哈夫曼树</h2><h2 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h2><p>带权路径长度 WPL 最小的二叉树，wi代表权值，li代表长度。WPL（带权路径长度）&#x3D;所有结点的权值*路径长度之和</p>
<p><img src="https://img-blog.csdnimg.cn/20181121230404510.png" alt="img"></p>
<h2 id="2-板子代码-优先队列"><a href="#2-板子代码-优先队列" class="headerlink" title="2.板子代码(优先队列)"></a>2.板子代码(优先队列)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line">priority_queue &lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		q.<span class="built_in">push</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">size</span>()==<span class="number">1</span>) &#123;ans=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">int</span> min1=q.<span class="built_in">top</span>();<span class="comment">//找最小值</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> min2=q.<span class="built_in">top</span>();<span class="comment">//找次小值</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		ans+=(min1+min2);<span class="comment">//记录总值</span></span><br><span class="line">		q.<span class="built_in">push</span>(min1+min2);<span class="comment">//将和又放回优先队列</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意优先队列取队头元素用q.top();</p>
<h3 id="二-哈夫曼编码（左0右1）"><a href="#二-哈夫曼编码（左0右1）" class="headerlink" title="二.哈夫曼编码（左0右1）"></a>二.哈夫曼编码（左0右1）</h3><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="一-3种构造图的方式"><a href="#一-3种构造图的方式" class="headerlink" title="一.3种构造图的方式"></a>一.3种构造图的方式</h2><h4 id="1-邻接矩阵-适合稠密图"><a href="#1-邻接矩阵-适合稠密图" class="headerlink" title="1.邻接矩阵(适合稠密图)"></a>1.邻接矩阵(适合稠密图)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn][maxn];<span class="comment">//没有边为0，或者无穷,有边为1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;<span class="comment">//n个点，m条边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="type">int</span> from,to;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to;<span class="comment">//有权值时 写成a[from][to]=wei;</span></span><br><span class="line">		a[from][to]=<span class="number">1</span>;<span class="comment">//有向图</span></span><br><span class="line">		a[from][to]=<span class="number">1</span>;<span class="comment">//无向图</span></span><br><span class="line">		a[to][from]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-邻接表（用vector"><a href="#2-邻接表（用vector" class="headerlink" title="2.邻接表（用vector)"></a>2.邻接表（用vector)</h4><h5 id="1-无权图"><a href="#1-无权图" class="headerlink" title="1.无权图"></a>1.无权图</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;<span class="comment">//n个点 m条边</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> from,to;</span><br><span class="line">        cin&gt;&gt;from&gt;&gt;to;</span><br><span class="line">        <span class="comment">//1.有向图</span></span><br><span class="line">        a[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        <span class="comment">//2.无向图</span></span><br><span class="line">        a[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        a[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-有权图"><a href="#2-有权图" class="headerlink" title="2.有权图"></a>2.有权图</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line">vector&lt;pii&gt; a[maxn];<span class="comment">//&#123;to,wei&#125;a[from]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;<span class="comment">//n个点 m条边</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="type">int</span> from,to,wei;</span><br><span class="line">        cin&gt;&gt;from&gt;&gt;to&gt;&gt;wei;</span><br><span class="line">        <span class="comment">//1.有向图</span></span><br><span class="line">        a[from].<span class="built_in">push_back</span>(&#123;to,wei&#125;);</span><br><span class="line">        <span class="comment">//2.无向图</span></span><br><span class="line">        a[from].<span class="built_in">push_back</span>(&#123;to,wei&#125;);</span><br><span class="line">        a[to].<span class="built_in">push_back</span>(&#123;from,wei&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-链式前向星"><a href="#3-链式前向星" class="headerlink" title="3.链式前向星"></a>3.链式前向星</h4><h3 id="1-解析"><a href="#1-解析" class="headerlink" title="1.解析"></a>1.解析</h3><h3 id="2-板子"><a href="#2-板子" class="headerlink" title="2.板子"></a>2.板子</h3><p>结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">xiaohan</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,w,next;<span class="comment">//终点 权值 表示与这个边起点相同的上一条边的编号</span></span><br><span class="line">&#125;edge[maxn];<span class="comment">//edge[i]--&gt;i代表from</span></span><br></pre></td></tr></table></figure>

<p>head[ i ]数组，表示以 i 为起点的最后一条边的编号，head数组一般初始化为-1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v; <span class="comment">//终点</span></span><br><span class="line">    edge[cnt].w = w; <span class="comment">//权值</span></span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    head[u] = idx++;<span class="comment">//idx为全局变量，起编号得作用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//n个起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[i]; j != <span class="number">-1</span>; j = edge[j].next)<span class="comment">//从以这个起点得最后一条边，从后到前开始遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].to &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].w &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="二-拓扑排序（入度为0将其排序）"><a href="#二-拓扑排序（入度为0将其排序）" class="headerlink" title="二.拓扑排序（入度为0将其排序）"></a>二.拓扑排序（入度为0将其排序）</h2><h3 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h3><p>1.选择入度为0的点</p>
<p>2.删除该点以及它出发的弧</p>
<p>3.回环往复，直到没有前驱结点</p>
<h3 id="2-板子："><a href="#2-板子：" class="headerlink" title="2.板子："></a>2.板子：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;a[maxn];<span class="comment">//邻接表存图</span></span><br><span class="line"><span class="type">int</span> insert[maxn];<span class="comment">//记录结点的度数</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topusort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="comment">//注意，当题目说了严格按照字典序的时候，我们应该用优先队列，否则就直接用普通队列</span></span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;qq;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(insert[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);<span class="comment">//先将刚开始入度为0的点，放入优先队列或则队列中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> x=q.<span class="built_in">top</span>();<span class="comment">//取出头顶元素</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		qq.<span class="built_in">push</span>(x);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a[x].<span class="built_in">size</span>();++i)&#123;<span class="comment">//遍历与它相邻的所有点，它们的入度都要减减	</span></span><br><span class="line">            <span class="type">int</span> v=a[x][i];</span><br><span class="line">			insert[v]--;</span><br><span class="line">			<span class="keyword">if</span>(insert[v]==<span class="number">0</span>) q.<span class="built_in">push</span>(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!qq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		cout&lt;&lt;qq.<span class="built_in">front</span>();</span><br><span class="line">		qq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(qq.<span class="built_in">size</span>()!=<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">	<span class="built_in">memset</span>(insert,<span class="number">0</span>,<span class="keyword">sizeof</span> insert);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="type">int</span> from,to;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to;</span><br><span class="line">		a[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">		insert[to]++;<span class="comment">//to的入度++</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">topusort</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i].<span class="built_in">clear</span>();<span class="comment">//清空图</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果题目要严格按照字典序排序时候我们应该用优先队列，否则就用队列就可以了！！！！</p>
<h3 id="3-判断有向图中有没有环（回路）"><a href="#3-判断有向图中有没有环（回路）" class="headerlink" title="3.判断有向图中有没有环（回路）"></a>3.判断有向图中有没有环（回路）</h3><p>​    如果队列元素个数少于点数，那么就形成了回路；因为回路的入度不可能为0，也就不可能进入队列。</p>
<p>​    <code>if(qq.size()&lt;n) cout&lt;&lt;&quot;为有环图&quot;&lt;&lt;endl;</code></p>
<h3 id="4-注意："><a href="#4-注意：" class="headerlink" title="4.注意："></a>4.注意：</h3><p>priority_queue 取队头元素用的是q.top();</p>
<p>queue 取队头元素用的是q.front();</p>
<h1 id="第三周笔记"><a href="#第三周笔记" class="headerlink" title="第三周笔记"></a>第三周笔记</h1><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><h2 id="一-Floyd算法-可以求任意俩点之间的距离）"><a href="#一-Floyd算法-可以求任意俩点之间的距离）" class="headerlink" title="一.Floyd算法(可以求任意俩点之间的距离）"></a>一.Floyd算法(可以求任意俩点之间的距离）</h2><h3 id="1-思想"><a href="#1-思想" class="headerlink" title="1.思想"></a>1.思想</h3><p>利用中转点k,更新i到j之间得距离。时间复杂度：o(n^3)</p>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;++k)<span class="comment">//中转站</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="comment">//枚举n个点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;<span class="built_in">j</span>&lt;=n;++j)</span><br><span class="line">		<span class="keyword">if</span>(dis[i][j]&gt;(dis[i][k]+dis[k][j]))  	dis[i][j]=dis[i][k]+dis[k][j];<span class="comment">//dis[i][j]代表i到j之间的距离</span></span><br></pre></td></tr></table></figure>



<h2 id="二-Dijkstra（按点更新-单源最短路径）"><a href="#二-Dijkstra（按点更新-单源最短路径）" class="headerlink" title="二.Dijkstra（按点更新  单源最短路径）"></a>二.Dijkstra（按点更新  单源最短路径）</h2><p>用于求一个点到其它点的最短距离。</p>
<h3 id="1-思想-1"><a href="#1-思想-1" class="headerlink" title="1.思想"></a>1.思想</h3><p>dis[]用来存当前这个点距离起点的距离，除了起点自己到自己的距离为0，其余的都初始化为无穷大。</p>
<p>vis[]用来标记当前的点被访问过没有。</p>
<h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> vis[maxn],dis[maxn];</span><br><span class="line">vector&lt;pii&gt; a[maxn];</span><br><span class="line">priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis,inf,<span class="keyword">sizeof</span> dis);</span><br><span class="line">	q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,start&#125;);</span><br><span class="line">	dis[start]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> t=q.<span class="built_in">top</span>().second;</span><br><span class="line">		<span class="type">int</span> w=q.<span class="built_in">top</span>().first;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[t]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			vis[t]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a[t].<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">				<span class="keyword">if</span>(dis[a[t][i].second]&gt;dis[t]+a[t][i].first)&#123;</span><br><span class="line">					dis[a[t][i].second]=dis[t]+a[t][i].first;</span><br><span class="line">					q.<span class="built_in">push</span>(&#123;dis[a[t][i].second],a[t][i].second&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,start;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;start;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> from,to,wei;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to&gt;&gt;wei;</span><br><span class="line">		a[from].<span class="built_in">push_back</span>(&#123;wei,to&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dijkstra</span>(start);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="三-Bellman-flod"><a href="#三-Bellman-flod" class="headerlink" title="三.Bellman-flod"></a>三.Bellman-flod</h2><h3 id="1-思想：-1"><a href="#1-思想：-1" class="headerlink" title="1.思想："></a>1.思想：</h3><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="一-prim-按点"><a href="#一-prim-按点" class="headerlink" title="一.prim(按点)"></a>一.prim(按点)</h2><h2 id="二-kruskal-按边）"><a href="#二-kruskal-按边）" class="headerlink" title="二.kruskal(按边）"></a>二.kruskal(按边）</h2><h3 id="1-思想-2"><a href="#1-思想-2" class="headerlink" title="1.思想"></a>1.思想</h3><p>每次选择一条权值最小得边，让这条边俩端点连通，如果已经连通，则不选。</p>
<p>第一步：边权值从小到大排个序(priority_queue)；</p>
<p>第二步：判断是否生成回路（并查集）</p>
<p>第三步：当到达n个点-1条边时，则最小生成树建成</p>
<h3 id="2-代码（P3366-【模板】最小生成树）"><a href="#2-代码（P3366-【模板】最小生成树）" class="headerlink" title="2.代码（P3366 【模板】最小生成树）"></a>2.代码（P3366 【模板】最小生成树）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span> </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xiaohan</span>&#123;<span class="comment">//结构体存边</span></span><br><span class="line">	<span class="type">int</span> from,to,wei;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(xiaohan x,xiaohan y)</span></span>&#123;<span class="comment">//自写cmp 按照边权值从小到大排序</span></span><br><span class="line">	<span class="keyword">return</span> x.wei&lt;y.wei;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nint</span><span class="params">()</span></span>&#123;<span class="comment">//并查集，初始化刚开始的父亲结点等于它自己</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//查找父亲结点函数</span></span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;<span class="comment">//如果它本身就是自己的父亲节点就直接返回</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);<span class="comment">//否则就不断递归找祖宗 直到找到根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	x=<span class="built_in">find</span>(x);</span><br><span class="line">	y=<span class="built_in">find</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果祖宗相同则说明已经在一个集合了</span></span><br><span class="line">	<span class="keyword">else</span> &#123;fa[x]=y;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">//否则就将y作为x的父亲结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>,ans=<span class="number">0</span>;<span class="comment">//记录已经连接边的条数 最小生成树的权值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*m;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">merge</span>(a[i].from,a[i].to))&#123;<span class="comment">//如果这条边还没连过，就连，为了不让它出现环</span></span><br><span class="line">			cnt++;<span class="comment">//所连边条数加加</span></span><br><span class="line">			ans+=a[i].wei;<span class="comment">//加上它的权值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt!=n<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;orz&quot;</span>&lt;&lt;endl;<span class="comment">//如果最后连的边没有到达点-1条，说明不可能生成最小生成树，输出orz</span></span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;<span class="comment">//否则说明建成最小生成树，就输出所建树的权值之和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;<span class="comment">//n个点 m条无向边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*m;i+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="type">int</span> from,to,wei;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to&gt;&gt;wei;<span class="comment">//存无向图</span></span><br><span class="line">		a[i].from=from;</span><br><span class="line">		a[i].to=to;</span><br><span class="line">		a[i].wei=wei;</span><br><span class="line">		a[i<span class="number">+1</span>].from=to;</span><br><span class="line">		a[i<span class="number">+1</span>].to=from;</span><br><span class="line">	    a[i<span class="number">+1</span>].wei=wei;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">nint</span>();<span class="comment">//初始化</span></span><br><span class="line">	<span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+2</span>*m<span class="number">+1</span>,cmp);<span class="comment">//按边权值从小到大排序</span></span><br><span class="line">	<span class="built_in">kruskal</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="LCA（最近公共祖先"><a href="#LCA（最近公共祖先" class="headerlink" title="LCA（最近公共祖先)"></a>LCA（最近公共祖先)</h1><h2 id="一-朴素法（一步一跳）"><a href="#一-朴素法（一步一跳）" class="headerlink" title="一.朴素法（一步一跳）"></a>一.朴素法（一步一跳）</h2><h3 id="1-思想-3"><a href="#1-思想-3" class="headerlink" title="1.思想"></a>1.思想</h3><p><img src="/images/image-20230726201736285.png" alt="c++算法图"></p>
<p> 假设要找F和E的LCA，先让F向上回溯到他的父节点D的位置，这样就与E处在同一深度了。然后让他们同时向上回溯（跳到他们的父节点上），直到两者相遇。相遇时所到达的那个点就是他们的最近公共祖先（即B）。</p>
<p>用dfs递归建树，邻接表存图</p>
<p>1.计算俩者的深度差</p>
<p>2.让深度深的往上跳，直到俩者深度相同</p>
<p>3.俩个点同时向上跳，跳至相遇。</p>
<h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> deep[maxn],fa[maxn],n,m,s<span class="comment">//deep存每个结点得深度，fa数组存每个结点得父亲结点 n个点 m个询问 s建树得根节点</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];<span class="comment">//邻接表存图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfsbuild</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//父亲结点 儿子结点</span></span><br><span class="line">	deep[v]=deep[u]<span class="number">+1</span>;<span class="comment">//儿子结点得深度=父亲结点深度+1</span></span><br><span class="line">	fa[v]=u;<span class="comment">//存一下父亲</span></span><br><span class="line">	<span class="type">int</span> len=a[v].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;<span class="comment">//遍历v邻接表所连得其它边</span></span><br><span class="line">		<span class="type">int</span> to=a[v][i];<span class="comment">//v的儿子结点</span></span><br><span class="line">		<span class="keyword">if</span>(u!=to)&#123;<span class="comment">//只要不是等于v的父亲结点，就将其与它的父亲v相连</span></span><br><span class="line">			<span class="built_in">build</span>(v,to);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span>&#123;<span class="comment">//找这俩个结点的最近公共祖先</span></span><br><span class="line">	<span class="keyword">if</span>(deep[v2]&gt;deep[v1]) <span class="built_in">swap</span>(v1,v2);<span class="comment">//保证v1存的升读最深的那个结点，方便后面的操作</span></span><br><span class="line">	<span class="keyword">while</span>(deep[v1]&gt;deep[v2])&#123;<span class="comment">//跳至深度相同的位置，停下来</span></span><br><span class="line">		v1=fa[v1];<span class="comment">//不断往上面跳（儿子=爸爸）</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(v1!=v2)&#123;<span class="comment">//一起往上跳，知道相遇</span></span><br><span class="line">		v1=fa[v1];</span><br><span class="line">		v2=fa[v2];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v1;<span class="comment">//最近公共祖先</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<span class="comment">//n个点 m个询问 s建树得根节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		a[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		a[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfsbuild</span>(<span class="number">0</span>,s);<span class="comment">//dfs建树(走到最深处)将根节点与空结点先连，空结点为根节点得父亲</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">lca</span>(x,y)&lt;&lt;endl;<span class="comment">//求x,y得最近公共祖先</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果建树的时候不能确定一个点是否在树中，也就是不能明确哪个结点是根时，我们可以考虑用一个数组去记录每个结点的入度，入度为0的点，就是根结点。或者用并查集处理</p>
<h2 id="二-倍增求Lca"><a href="#二-倍增求Lca" class="headerlink" title="二.倍增求Lca"></a>二.倍增求Lca</h2><h3 id="1-思想-4"><a href="#1-思想-4" class="headerlink" title="1.思想"></a>1.思想</h3><p>任何数都可以拆分成很多个2的幂次之和 eg.10&#x3D;8（2^3）+2(2^1);因此我们可以把所要求的俩个点相差的深度二进制拆分。每次往上跳2^i格。</p>
<p>用dfs递归建树，邻接表存图（边存树，边去利用前面的<code>fa[][]</code>信息去找当前的<code>fa[][]</code>信息</p>
<p>1.计算俩者的深度差</p>
<p>2.让深度深的往上跳，直到俩者深度相同</p>
<p>3.俩个点同时向上跳，跳至相遇。</p>
<p>fa数组求法：<code>fa[i][j]</code>表示i这个结点向上跳2^j格；</p>
<p><code>fa[儿子][1]=fa[fa[儿子][0]][0]</code></p>
<p><code>fa[儿子][0]</code>儿子往上面跳2^0&#x3D;1格，到达父亲，父亲再向上跳<code>fa[父亲][0]</code>2^0&#x3D;1格，到达爷爷</p>
<p><img src="/images/image-20230727155051347.png" alt="c++算法图"></p>
<h3 id="2-代码-P3379-【模板】最近公共祖先（LCA）"><a href="#2-代码-P3379-【模板】最近公共祖先（LCA）" class="headerlink" title="2.代码(P3379 【模板】最近公共祖先（LCA）)"></a>2.代码(P3379 【模板】最近公共祖先（LCA）)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> deep[maxn],fa[maxn][<span class="number">40</span>];<span class="comment">//deep 记录每个结点的深度  fa[i][j]  记录每个i结点可以向上跳2^j格，即找到向上跳的祖宗结点</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];<span class="comment">//邻接表存图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//建树 父亲结点 儿子结点</span></span><br><span class="line">	fa[v][<span class="number">0</span>]=u;<span class="comment">//儿子跳2^0(1)格子到达父亲</span></span><br><span class="line">	deep[v]=deep[u]<span class="number">+1</span>;<span class="comment">//儿子结点的深度=父亲结点的深度加1</span></span><br><span class="line">	<span class="type">int</span> len=a[v].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=deep[v];++i)&#123;<span class="comment">//往上计算自己可以向上跳的格子</span></span><br><span class="line">		fa[v][i]=fa[fa[v][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;<span class="comment">//v的儿子结点</span></span><br><span class="line">		<span class="type">int</span> to=a[v][i];</span><br><span class="line">		<span class="keyword">if</span>(u!=to)&#123;<span class="comment">//只要不是等于v的父亲结点，就将其与它的父亲v相连</span></span><br><span class="line">			<span class="built_in">build</span>(v,to);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lac</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//找这俩个结点的最近公共祖先</span></span><br><span class="line">	<span class="keyword">if</span>(deep[x]&lt;deep[y]) <span class="built_in">swap</span>(x,y);<span class="comment">//保证x存的升读最深的那个结点，方便后面的操作</span></span><br><span class="line">	<span class="type">int</span> h=deep[x]-deep[y];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=(<span class="number">1</span>&lt;&lt;i);j&lt;=h;++i,j=(<span class="number">1</span>&lt;&lt;i))&#123;<span class="comment">//先跳小步 再跳大步（所以左移）跳至深度相同的位置，停下来</span></span><br><span class="line">		<span class="keyword">if</span>(h&amp;j)&#123;<span class="comment">//当j的二进制为1时跳！</span></span><br><span class="line">			x=fa[x][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;<span class="comment">//如果一个结点就是另一结点的根，说明到达相同位置时已经是公共祖先</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=(<span class="type">int</span>)(<span class="built_in">log</span>(deep[x])/<span class="built_in">log</span>(<span class="number">2</span>));i&gt;=<span class="number">0</span>;--i)&#123;<span class="comment">//否则就应该同时向上跳，这里i也可以写成一个不超过35的数字，不断枚举，不断逼近最近公共祖先的下一个子节点</span></span><br><span class="line">		<span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;<span class="comment">//当他们可以跳到不是公共祖先时，就跳</span></span><br><span class="line">			x=fa[x][i];</span><br><span class="line">			y=fa[y][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>];<span class="comment">//返回最近公共祖先的下一个子节点再往上跳一个（2^0)就到达公共祖先</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m,s;<span class="comment">//n个点 m次询问 s为起点</span></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> from,to;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to;</span><br><span class="line">		a[from].<span class="built_in">push_back</span>(to);<span class="comment">//无向图</span></span><br><span class="line">	    a[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">0</span>,s);<span class="comment">//dfs建树(走到最深处)将根节点与空结点先连，空结点为根节点得父亲</span></span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">lac</span>(x,y)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="强连通与tarjan"><a href="#强连通与tarjan" class="headerlink" title="强连通与tarjan"></a>强连通与tarjan</h1><h2 id="一-概念"><a href="#一-概念" class="headerlink" title="一.概念"></a>一.概念</h2><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p><strong>什么是强连通图？</strong><br>如果一个有向图中，存在一条回路，所有的结点至少被经过一次，这样的图为强连通图。<br><img src="https://img-blog.csdnimg.cn/20190310214919259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0MzgzNQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>什么是强连通分量？</strong></p>
<p>强连通图中包含的点</p>
<h2 id="二-思想"><a href="#二-思想" class="headerlink" title="二.思想"></a>二.思想</h2><p>强连通分量就是有向图中一个回路包含的点。所以我们得去找这样得回路。</p>
<p>进栈-》标记进栈-》遍历后面点-》如果没跑过-》tarjan（）-》如果在栈里面-》更新所属强连通点low-》判断是否连通（自己是前根子结点）-》连通图加加-》出栈（清楚标记)-》添色-》size++;</p>
<p>思路就是，在建树得时候，我们都去记录一下每个点是什么时候建立进去的，以及它的后向根是谁，然后将它入栈，再用一个是否进栈数组标记一下,遍历后面连得点，如果还没有进去过，就dfstarjan继续深搜建图。如果在栈里面的话，代表已经遍历过了，更新所属强连通点low，判断是否连通（自己是前根子结点），如果是的话连通图加加，出栈（清除标记)，添色，size++。</p>
<h2 id="三-代码"><a href="#三-代码" class="headerlink" title="三.代码"></a>三.代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> insertstack[maxn];<span class="comment">//标记结点是否在栈中</span></span><br><span class="line"><span class="type">int</span> low[maxn];<span class="comment">//记录自己得后根结点（可以连接后向边得那个结点）</span></span><br><span class="line"><span class="type">int</span> dfn[maxn];<span class="comment">//记录建图得顺序，时间顺序</span></span><br><span class="line"><span class="type">int</span> size[maxn];<span class="comment">//记录强连通图得强连通分量</span></span><br><span class="line"><span class="type">int</span> clor[maxn];<span class="comment">//添色</span></span><br><span class="line"><span class="type">int</span> timestamp,cnt,u;<span class="comment">//时间冲 强连通图的个数 </span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;<span class="comment">//tarjan算法 dfs建图</span></span><br><span class="line">	low[u]=dfn[u]=++timestamp;<span class="comment">//记录可以连接的后向边的那个结点 建图的时间冲 刚开始为时间冲</span></span><br><span class="line">	s.<span class="built_in">push</span>(u);<span class="comment">//进栈</span></span><br><span class="line">	insertstack[u]=<span class="number">1</span>;<span class="comment">//表记在栈里面</span></span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">	<span class="type">int</span> len=a[u].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;<span class="comment">//遍历所连后面的结点</span></span><br><span class="line">		v=a[u][i];</span><br><span class="line">		<span class="keyword">if</span>(dfn[v]==<span class="number">0</span>)&#123;<span class="comment">//如果还没有建过图</span></span><br><span class="line">			<span class="built_in">tarjan</span>(v);<span class="comment">//就tarjan建图</span></span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);<span class="comment">//更新自己所连的后向边所连的结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(insertstack[v]==<span class="number">1</span>)&#123;<span class="comment">//如果这个结点已经在栈中出现过了</span></span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],dfn[v]);<span class="comment">//更新所连的后向边所连的结点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==dfn[u])&#123;<span class="comment">//自己就为一个前根子结点</span></span><br><span class="line">		++cnt;<span class="comment">//强连通点加加</span></span><br><span class="line">		<span class="keyword">do</span>&#123;<span class="comment">//出栈 填色 强连通分量个数加加 取消在栈中的标记</span></span><br><span class="line">			v=s.<span class="built_in">top</span>();</span><br><span class="line">			s.<span class="built_in">pop</span>();</span><br><span class="line">			clor[v]=cnt;</span><br><span class="line">			size[cnt]++;</span><br><span class="line">			insertstack[v]=<span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">while</span>(u!=v);<span class="comment">//直到剩下前根子节点为止</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">		<span class="type">int</span> from,to;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to;</span><br><span class="line">		a[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dfn[i]==<span class="number">0</span>)&#123;<span class="comment">//如果还没有时间冲，代表还没有被建过，就建。</span></span><br><span class="line">		<span class="built_in">tarjan</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h1><h2 id="一-Dinic算法（o-n-2-m-重点）"><a href="#一-Dinic算法（o-n-2-m-重点）" class="headerlink" title="一.Dinic算法（o(n^2*m)重点）"></a>一.Dinic算法（o(n^2*m)重点）</h2><p><img src="/images/image-20230728171802463.png" alt="c++算法图"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">0x35f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> head[maxn],deep[maxn],cur[maxn],flow[maxn],idex=<span class="number">2</span>;</span><br><span class="line"><span class="comment">//deep代表层次（深度） idex必须从偶数开始(偶数为正向边 奇数为反向边)</span></span><br><span class="line"><span class="type">int</span> n,m,start,end1;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xiaohan</span>&#123;</span><br><span class="line">	<span class="type">int</span> to,wei,pre;</span><br><span class="line">&#125;edge[<span class="number">2</span>*maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	edge[idex].to=v;</span><br><span class="line">	edge[idex].wei=w;</span><br><span class="line">	edge[idex].pre=head[u];</span><br><span class="line">	head[u]=idex;</span><br><span class="line">	idex++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs_deep</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(deep,<span class="number">0</span>,<span class="keyword">sizeof</span> deep);</span><br><span class="line">	<span class="built_in">memcpy</span>(cur,head,<span class="keyword">sizeof</span> head);</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(start);<span class="comment">//起点入队</span></span><br><span class="line">	deep[start]=<span class="number">1</span>;<span class="comment">//层次加一</span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].pre)&#123;</span><br><span class="line">			<span class="type">int</span> v=edge[i].to;</span><br><span class="line">			<span class="type">int</span> w=edge[i].wei;</span><br><span class="line">			<span class="keyword">if</span>(w&gt;<span class="number">0</span>&amp;&amp;deep[v]==<span class="number">0</span>)&#123;<span class="comment">//如果通量大于0并且还没有被访问过</span></span><br><span class="line">				deep[v]=deep[u]<span class="number">+1</span>;<span class="comment">//它的层次等于上一个结点的层次加一</span></span><br><span class="line">				q.<span class="built_in">push</span>(v);<span class="comment">//将它入队</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (deep[end1]!=<span class="number">0</span>);<span class="comment">//如果末尾位置深度为0代表为不连通图，就返回0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> cur_flow)</span></span>&#123;<span class="comment">//点  当前的的流通量</span></span><br><span class="line">	<span class="keyword">if</span>(u==end1) <span class="keyword">return</span> cur_flow;<span class="comment">//如果流到终点位置就递归回去，处理边，递归到47行代码</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=cur[u];i;i=edge[i].pre)&#123;<span class="comment">//遍历</span></span><br><span class="line">		cur[u]=i;</span><br><span class="line">		<span class="type">int</span> v=edge[i].to;</span><br><span class="line">		<span class="type">int</span> w=edge[i].wei;</span><br><span class="line">		<span class="type">int</span> c=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(deep[v]==deep[u]<span class="number">+1</span>&amp;&amp;w&gt;<span class="number">0</span>&amp;&amp;(c=<span class="built_in">dfs</span>(v,<span class="built_in">min</span>(cur_flow,w))))&#123;</span><br><span class="line">			edge[i].wei-=c;<span class="comment">//正向边减去流通量   eg.4</span></span><br><span class="line">			edge[i^<span class="number">1</span>].wei+=c;<span class="comment">//反向边加上流通量 eg.4^1 4的二进制为  0100^1=0101=5所以偶数为正向边，负数为反向边</span></span><br><span class="line">			<span class="keyword">return</span> c;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans_maxflow=<span class="number">0</span>;<span class="comment">//计算最大流</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs_deep</span>()!=<span class="number">0</span>)&#123;<span class="comment">//判断结束位置的层次是不是为0，不是0时才深搜求通量，是0，代表不是连通图，不可能到达结束位置</span></span><br><span class="line">		ans_maxflow+=<span class="built_in">dfs</span>(start,inf);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans_maxflow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;start&gt;&gt;end1;<span class="comment">//n个点 m条边 开始位置 到达位置</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> from,to,wei;</span><br><span class="line">		cin&gt;&gt;from&gt;&gt;to&gt;&gt;wei;</span><br><span class="line">		<span class="built_in">add</span>(from,to,wei);<span class="comment">//正向边</span></span><br><span class="line">		<span class="built_in">add</span>(to,from,<span class="number">0</span>);<span class="comment">//反向边</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">dinic</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四周笔记"><a href="#第四周笔记" class="headerlink" title="第四周笔记"></a>第四周笔记</h1><h1 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h1><h1 id="二部图"><a href="#二部图" class="headerlink" title="二部图"></a>二部图</h1><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="一-0-1背包-每件物品只有1件"><a href="#一-0-1背包-每件物品只有1件" class="headerlink" title="一.0-1背包(每件物品只有1件)"></a>一.0-1背包(每件物品只有1件)</h2><h3 id="1-思想-5"><a href="#1-思想-5" class="headerlink" title="1.思想"></a>1.思想</h3><p><img src="/images/image-20230801133943870.png" alt="c++算法图"></p>
<p>1.<code>dp[i][j]</code>代表在容量为j的背包容量下，前i个物品最大可以装的价值。</p>
<p>当遍历到第i个物品时：</p>
<p>a.当前背包容量大于等于物品体积，<strong>可以装下</strong>此时的第i件物品  就有俩种选择装与不装  比较俩者情况，取最大值</p>
<p>装：就为当前背包容量减去要想装下当前这个物品所消耗的体积下所装下前i-1个物品的最大值，加上当前这个物品的价值</p>
<p>不装：此时dp<code>[i][j]</code>为当前背包容量下前i-1个物品的最大价值</p>
<p>b.当前背包容量小于物品体积，<strong>装不下</strong>此时的第i件物品    则此时dp<code>[i][j]</code>为当前背包容量下前i-1个物品的最大价值</p>
<h3 id="2-二维代码"><a href="#2-二维代码" class="headerlink" title="2.二维代码"></a>2.二维代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];<span class="comment">//dp[i][j]表示在容量j的背包容量下，前i件物品可以装的最大价值</span></span><br><span class="line"><span class="type">int</span> w[maxn],v[maxn];<span class="comment">//w为物品体积  v为物品价值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum,n;<span class="comment">//背包容量sum n为物品件数</span></span><br><span class="line">	cin&gt;&gt;sum&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sum;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(w[i]&gt;j) dp[i][j]=dp[i<span class="number">-1</span>][j];<span class="comment">//如果当前物品体积大于背包容量，装不下，此时dp`[i][j]`为当前背包容量下前i-1个物品的最大价值</span></span><br><span class="line">			<span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);<span class="comment">//当前背包容量大于等于物品体积，可以装下此时的第i件物品  就有俩种选择装与不装  比较俩者情况，取最大值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//装：就为当前背包容量减去要想装下当前这个物品所消耗的体积下所装下前i-1个物品的最大值，加上当前这个物品的价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不装：此时dp`[i][j]`为当前背包容量j下前i-1个物品的最大价值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[n][sum]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-一维优化思想："><a href="#3-一维优化思想：" class="headerlink" title="3.一维优化思想："></a>3.一维优化思想：</h3><p><img src="/images/image-20230801134952755.png" alt="c++算法图"></p>
<p>但是我们的反向迭代从背包容量到当前的物品体积为什么呢？<br>       1.放在二维当中，新的一排迭代，是不是需要靠前面一排的值来迭代 ，就是上一排的值和前面的值，也就是说第二排靠第一排的值。</p>
<p>2.但在一维当中，没有前一排的值来迭代，只有一维，所以我们要想办法把第一排的值保留下来去刷新第二排，一维怎么保留前一排了，保留不了，这个时候有个规律，数组中后面的值是不是靠上一排的前面迭代，也就是说在一个一维数组中，我前面的值不动，后面的直接去迭代，用一维的前面值，这个时候一维的前面一部分值是不是没有被刷新，没有刷新是不是就是上一排的旧值，但如果你正向迭代就错了，因为前面的值是不是会发生改变，后面就值就会错误了</p>
<p>3.所以呢，我们跑第四轮的时候，我们需要第三轮的值，如果正向迭代的话，前面的数值刷新成了第四轮的，也就被染指了，不干净了，所以的反向迭代，但是二维数组捏，无论反向迭代还是正向迭代都有一个位置具体记录好每一轮的具体值，都可以跑。而一维是一个一维的滚动数组，值不停的刷新，我们想要上一轮的值，那就的反向迭代。</p>
<h3 id="4-一维滚动数组代码"><a href="#4-一维滚动数组代码" class="headerlink" title="4.一维滚动数组代码"></a>4.一维滚动数组代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> sum,n,dp[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;sum&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> w,v;</span><br><span class="line">		cin&gt;&gt;w&gt;&gt;v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=w;--j)&#123;</span><br><span class="line">			dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w]+v);<span class="comment">//max(容量为j的前i（1~i-1）个物品的最大价值此时的任然是上一轮的容量为j的最大价值因为本轮dp[j]还没更新（其它也是哦），容量为j-w下前i-1个物品的最大价值加装上本件物品的价值)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[sum]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-完全背包（每种物品数量为无限件）"><a href="#二-完全背包（每种物品数量为无限件）" class="headerlink" title="二.完全背包（每种物品数量为无限件）"></a>二.完全背包（每种物品数量为无限件）</h2><h3 id="1-思想-6"><a href="#1-思想-6" class="headerlink" title="1.思想"></a>1.思想</h3><p><strong>先继承上一层状态</strong></p>
<p><strong>判断放不放的下</strong></p>
<p><strong>选和不选</strong></p>
<h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="2.代码"></a>2.代码</h3><p><strong>二维代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> w[maxn],v[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum,n;</span><br><span class="line">    cin&gt;&gt;sum&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sum;++j)&#123;</span><br><span class="line">            <span class="comment">//先继承</span></span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">//考虑选还是不选</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">                dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i][j-w[i]]+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;max=&quot;</span>&lt;&lt;dp[n][sum]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一维优化代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> sum,n,dp[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;sum&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> w,v;</span><br><span class="line">		cin&gt;&gt;w&gt;&gt;v;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=w;j&lt;=sum;++j)&#123;<span class="comment">//正向迭代</span></span><br><span class="line">			dp[j]=<span class="built_in">max</span>(dp[j],dp[j-w]+v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[sum]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="三-多重背包（每种物品数量有限件）"><a href="#三-多重背包（每种物品数量有限件）" class="headerlink" title="三.多重背包（每种物品数量有限件）"></a>三.多重背包（每种物品数量有限件）</h2><p>方法1：将多重背包转为0-1背包（注意数据范围）</p>
<p>方法2：二进制优化（难点）</p>
<h2 id="四-分组背包（每组一些物品，最多在每组里面选1件）"><a href="#四-分组背包（每组一些物品，最多在每组里面选1件）" class="headerlink" title="四.分组背包（每组一些物品，最多在每组里面选1件）"></a>四.分组背包（每组一些物品，最多在每组里面选1件）</h2><p><code>dp[i][j]</code>具体到每个组每个容量，不是滚动dp,可以正反向遍历都行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];<span class="comment">//dp[i][j]表示考虑第i组物品，剩余容量为j的背包能装的最大价值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; w[maxn];<span class="comment">//w[i][j] 代表第i组物品的第几件物品的重量</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[maxn];<span class="comment">//v[i][j] 代表第i组物品的第几件物品的价值</span></span><br><span class="line"><span class="type">int</span> sum,n,t;<span class="comment">//背包容量 物品件数 组数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;sum&gt;&gt;n&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">int</span> wei,val,z;</span><br><span class="line">		cin&gt;&gt;wei&gt;&gt;val&gt;&gt;z;</span><br><span class="line">		w[z].<span class="built_in">push_back</span>(wei);</span><br><span class="line">		v[z].<span class="built_in">push_back</span>(val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;++i)&#123;<span class="comment">//物品组数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sum;++j)&#123;<span class="comment">//背包容量</span></span><br><span class="line">			<span class="type">int</span> len=w[i].<span class="built_in">size</span>();</span><br><span class="line">			<span class="keyword">if</span>(len==<span class="number">0</span>)&#123;<span class="comment">//因为二维数组，物品组数必须相邻，不能有断层，如果断层了，那一排的dp全为0，会影响后面的继承，所以当断层时，我们应该将上一组的dp抄过来</span></span><br><span class="line">				dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> o=<span class="number">0</span>;o&lt;len;++o)&#123;<span class="comment">//这一组的物品件数</span></span><br><span class="line">					<span class="keyword">if</span>(j&gt;=w[i][o]) dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j-w[i][o]]+v[i][o]);<span class="comment">//如果背包容量大于等于此时这一组第o件物品的重量，就有俩种选择。</span></span><br><span class="line">					<span class="comment">//1.不选 2.选 就为上一组在此时背包容量减去要装下物品消耗的容量下的最大价值+装下这个物品的价值</span></span><br><span class="line">					<span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j]);<span class="comment">//如果背包容量小于此时这一组第o件物品的重量 那么就装不下不选，一组有多件，所以要用dp[i][j]去更新</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[t][sum]&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线性动规"><a href="#线性动规" class="headerlink" title="线性动规"></a>线性动规</h1><p><strong>dp动态规划三部曲</strong>：设置状态</p>
<p>​                                 转移方程</p>
<p>​                                  临界点（极端情况下的情况）</p>
<h2 id="一-LIS（最长上升子序列）"><a href="#一-LIS（最长上升子序列）" class="headerlink" title="一.LIS（最长上升子序列）"></a>一.LIS（最长上升子序列）</h2><h3 id="1-什么是子序列"><a href="#1-什么是子序列" class="headerlink" title="1.什么是子序列"></a>1.什么是子序列</h3><p>abdgj   <strong>子序列</strong>：agj   abj  就是<strong>相对位置不变</strong>             <strong>子串</strong>：abd dgj<strong>必须相邻</strong></p>
<h3 id="2-求LIS思路"><a href="#2-求LIS思路" class="headerlink" title="2.求LIS思路"></a>2.求LIS思路</h3><p><strong>方法1：利用dp思想  时间o(n^2);</strong></p>
<p>思路：</p>
<p>dp[i]:表示a[1]~a[i]所有数的最长上升子序列</p>
<p>dp[i]&#x3D;maxdp[j]+1 (条件：1&lt;&#x3D;j&lt;i;a[j]&lt;a[i])</p>
<p><img src="/images/image-20230802133343875.png" alt="c++算法图"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],dp[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		dp[i]=<span class="number">1</span>;<span class="comment">//刚开始自己就算一个子序列，至少最长上升子序列为1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;++j)&#123;<span class="comment">//枚举前i个最长的上升子序列</span></span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[i]) dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);<span class="comment">//如果前面数字小于当前的a[i]，则这个位置的最小上升子序列等于它更新的最长上升子序列与当前比它小的那个数的最长上升子序列+1取最大值</span></span><br><span class="line">		&#125;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,dp[i]);<span class="comment">//每个位置都保存了1~i（1到当前位置的最长上升子序列） 直接取最大值就可以了</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法2：low数组二分查找</strong> o(n*logN)（最佳）</p>
<p>思路：</p>
<p>我们想要得到最长上升子序列，就应该得到上升更慢的，比如1 3比1 4上升更慢，以至于后面更多的元素可以加入序列中，上升空间更大。也就是说如果我维护的子序列上升的速度越慢，就更容易加入更多的元素。</p>
<p><img src="/images/image-20230802135327587.png" alt="c++算法图"></p>
<p><img src="/images/image-20230802140234349.png" alt="c++算法图"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],low[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;a[<span class="number">1</span>];</span><br><span class="line">	<span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line">	low[++f]=a[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;low[f]) low[++f]=a[i];<span class="comment">//当后面序列元素大于了low数组中最后一个元素，直接加入low数组里面</span></span><br><span class="line">		<span class="keyword">if</span>(a[i]&lt;low[f])&#123;<span class="comment">//当后面序列元素小于low数组中最后一个元素</span></span><br><span class="line">			<span class="type">int</span> pos=<span class="built_in">lower_bound</span>(low,low+f,a[i])-low;<span class="comment">//找到low数组中第一个大于等于当前元素的位置，将它替换掉</span></span><br><span class="line">			low[pos]=a[i];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f&lt;&lt;endl;<span class="comment">//最长上升子序列就为此时low数组的元素个数 low数组里也是一组最长公共子序列解</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-LCA（最长公共子序列）"><a href="#二-LCA（最长公共子序列）" class="headerlink" title="二.LCA（最长公共子序列）"></a>二.LCA（最长公共子序列）</h2><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="1.思路"></a>1.思路</h3><p>eg.s:    ABCBDAB</p>
<p>​     s1:  BDCABA   最长公共子序列为BCAB</p>
<p>状态：<code>dp[i][j]</code>表示字符串s前i个字符和字符串s1前j个字符的最长公共子序列</p>
<p>转移方程：</p>
<p><img src="/images/image-20230802142405448.png" alt="c++算法图"></p>
<h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="2.代码"></a>2.代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line">string s,s1;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> len,len1;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;s&gt;&gt;s1)&#123;</span><br><span class="line">		s=<span class="string">&#x27; &#x27;</span>+s;<span class="comment">//预处理，因为s字符串是从下标0开始的，而我们要从一开始，防止后面dp[i-1]越界，所以用空字符占位</span></span><br><span class="line">		s1=<span class="string">&#x27; &#x27;</span>+s1;</span><br><span class="line">		len=s.<span class="built_in">size</span>();<span class="comment">//计算字符串长度</span></span><br><span class="line">		len1=s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;len1;++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==s1[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;<span class="comment">//当俩个字符相同时 就s字符串中前i-1和s1字符串中前j-1的最长公共子序列长度+1；</span></span><br><span class="line">				<span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);<span class="comment">//不同时，此时的最长公共子序列为：s字符串中前i-1个字符和s1字符串中前j个字符的最长公共子序列 与 s字符串中前i个字符和s1字符串中前j-1个字符的最长公共子序列取最大值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;dp[len<span class="number">-1</span>][len1<span class="number">-1</span>]&lt;&lt;endl;<span class="comment">//最长公共子序列</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="马拉车算法（最大回文字符串）"><a href="#马拉车算法（最大回文字符串）" class="headerlink" title="马拉车算法（最大回文字符串）"></a>马拉车算法（最大回文字符串）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> len[maxn];</span><br><span class="line"><span class="function">string <span class="title">nint</span><span class="params">()</span></span>&#123;<span class="comment">//预处理字符串aba -&gt;@#a#b#a#0    abba-&gt;@#a#b#b#a#0为什么要这样子捏？</span></span><br><span class="line">	<span class="comment">//因为回文字符串aba是奇回文串，回文中心为b。回文字符串abba为偶回文串，</span></span><br><span class="line">	<span class="comment">//回文中心为中间空白处，所以捏，预处理一下，都变成奇回文串。而俩边的@0字符是防止回文跑越界，好处理一点啦</span></span><br><span class="line">	string c;</span><br><span class="line">	c+=<span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">	<span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">		c+=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">		c+=s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	c+=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">	c+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> r=<span class="number">-1</span>,id=<span class="number">-1</span>,mlen=<span class="number">-1</span>;<span class="comment">//最长回文右边界的下一位扩展不动了 回文中心 最大回文半径</span></span><br><span class="line">	<span class="type">int</span> lenn=s.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lenn;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;r) len[i]=<span class="number">1</span>;<span class="comment">//如果当前枚举的这个中心大于了最右边界，不能借用前面的信息，自己len[i]=1暴力扩展</span></span><br><span class="line">		<span class="keyword">else</span> len[i]=<span class="built_in">min</span>(len[<span class="number">2</span>*id-i],r-i);<span class="comment">//如果当前枚举这个中心捏在右边界里面捏，可以借用前面知道的信息，减少扩展次数。</span></span><br><span class="line">		<span class="comment">//1.当这个点对应左边知道的最长回文半径大于了最右边界到此时中心位置 那么此时中心位置的最长回文半径捏就等于r-i，再继续扩展</span></span><br><span class="line">		<span class="comment">//2.当这个点对应左边知道的最长回文半径小于了最右边界到此时中心位置 那么此时中心位置的最长回文半径捏在继承前面已知的最长回文半径，再继续扩展</span></span><br><span class="line">		<span class="keyword">while</span>(s[i+len[i]]==s[i-len[i]]) len[i]++;<span class="comment">//暴力扩展</span></span><br><span class="line">		<span class="keyword">if</span>(i+len[i]&gt;r)&#123;<span class="comment">//当扩展中心位置+它可以回文半径大于了最右边界，就得更新最右边界，回文中心，以及最大的回文半径</span></span><br><span class="line">			r=i+len[i];</span><br><span class="line">			id=i;</span><br><span class="line">			mlen=<span class="built_in">max</span>(mlen,len[i]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mlen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	s=<span class="built_in">nint</span>();</span><br><span class="line">	<span class="comment">//cout&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">	cout&lt;&lt;<span class="built_in">manacher</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="KMP算法-字符串匹配问题"><a href="#KMP算法-字符串匹配问题" class="headerlink" title="KMP算法(字符串匹配问题)"></a>KMP算法(字符串匹配问题)</h1><h3 id="1-KMP解决的问题："><a href="#1-KMP解决的问题：" class="headerlink" title="1.KMP解决的问题："></a>1.KMP解决的问题：</h3><p>字符串s1是否在字符串s中出现过，如果出现过起始位置是什么</p>
<p>匹配串s2:ababcbd;  模式串s1:cbd；该s1在s中出现过，可以匹配上</p>
<h3 id="2-KMP算法思想"><a href="#2-KMP算法思想" class="headerlink" title="2.KMP算法思想"></a>2.KMP算法思想</h3><p>因为我们幼稚匹配时候捏，我们遇到不相同字符的时候捏，就又从上次开始匹配的下一位又开始匹配，<br> 我们会发现这样捏，时间复杂度很高。所以捏kmp算法捏是靠前面知道的信息，来减少匹配次数，那我们想要的信息是什么捏？</p>
<p>那就得说说next数组了，next数组里面装得是模式串s1得最长相同前后缀长度(不包含它自己本身)；我们知道了next数组，我们这样就可以减少回退次数，减少吃回头草的次数咯。</p>
<p>next数组:</p>
<p><img src="/images/image-20230803154735474.png" alt="c++算法图"></p>
<p>kmp:</p>
<p><img src="/images/image-20230803152123896.png" alt="c++算法图"></p>
<h3 id="3-KMP代码："><a href="#3-KMP代码：" class="headerlink" title="3.KMP代码："></a>3.KMP代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> next1[maxn];<span class="comment">//最长相同前后缀长度 也可以看作是每次回退时，可以回退到相同前缀的下一位</span></span><br><span class="line">string s,s1;<span class="comment">//匹配串 模式串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnext</span><span class="params">()</span></span>&#123;<span class="comment">//构造next1数组</span></span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">-1</span>;</span><br><span class="line">	next1[<span class="number">0</span>]=<span class="number">-1</span>;<span class="comment">//第一个字符前面没有字符，所以为-1，next数组求最长相同前后缀时不包含本身</span></span><br><span class="line">	<span class="keyword">while</span>(s1[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||s1[i]==s1[j]) next1[++i]=++j;<span class="comment">//当不能再向前面走以及当前后俩个字符相等是。next数组都为++j；</span></span><br><span class="line">		<span class="comment">//如果j!=-1,但俩个字母相同，此时next数组等于这个匹配位置上一个位置的next+1</span></span><br><span class="line">		<span class="keyword">else</span> j=next1[j];<span class="comment">//向前找</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">getnext</span>();</span><br><span class="line">	<span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(s[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span>||s[i]==s1[j])&#123;</span><br><span class="line">			i++;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">if</span>(!s1[j])&#123;<span class="comment">//当后一个s[j]为\0时，代表匹配成功了，flag标记</span></span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> j=next1[j];<span class="comment">//回退到最长相同前缀的下一位</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;s1;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">kmp</span>()&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h3 id="1-高精度加法"><a href="#1-高精度加法" class="headerlink" title="1.高精度加法"></a>1.高精度加法</h3><p>图解</p>
<p><img src="/images/image-20230804155758711.png" alt="c++算法图"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line">string s,s1;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],ans[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;s1;</span><br><span class="line">	<span class="type">int</span> k,k1,kk;</span><br><span class="line">	k=s.<span class="built_in">size</span>();</span><br><span class="line">	k1=s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;<span class="comment">//123</span></span><br><span class="line">		a[k-i<span class="number">-1</span>]=s[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">// 321</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k1;++i)&#123;<span class="comment">//456</span></span><br><span class="line">		b[k1-i<span class="number">-1</span>]=s1[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//654</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;k1) kk=k;</span><br><span class="line">	<span class="keyword">else</span> kk=k1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kk;++i)&#123;<span class="comment">//321+654-&gt;975-&gt;翻转579</span></span><br><span class="line">		ans[i]+=(a[i]+b[i]);<span class="comment">//+=不能漏</span></span><br><span class="line">		<span class="keyword">if</span>(ans[i]&gt;=<span class="number">10</span>)&#123;<span class="comment">//进位处理</span></span><br><span class="line">	    ans[i<span class="number">+1</span>]+=(ans[i]/<span class="number">10</span>);<span class="comment">//注意一定要写成ans[i+1]不能写成ans[i++]</span></span><br><span class="line">		ans[i]%=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(ans[kk]&gt;<span class="number">0</span>) kk++;<span class="comment">//判断是否进位到了kk位</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=kk<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) cout&lt;&lt;ans[i];</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-高精度减法"><a href="#2-高精度减法" class="headerlink" title="2.高精度减法"></a>2.高精度减法</h3><p><img src="/images/image-20230804164306775.png" alt="c++算法图"></p>
<p><img src="/images/image-20230804164325351.png" alt="c++算法图"></p>
<p>代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line">string s,s1;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],ans[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;<span class="comment">//特判减数和被减数哪个更小</span></span><br><span class="line">	<span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;s<span class="number">1.</span><span class="built_in">size</span>()||(s.<span class="built_in">size</span>()==s<span class="number">1.</span><span class="built_in">size</span>()&amp;&amp;s&gt;s1))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> k,k1;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;s1;</span><br><span class="line">	<span class="comment">//s.a存max</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">fun</span>())&#123;<span class="comment">//s更小 3-5这种情况 3-5=-(5-3)</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">		<span class="built_in">swap</span>(s,s1);</span><br><span class="line">	&#125;</span><br><span class="line">	k=s.<span class="built_in">size</span>();</span><br><span class="line">	k1=s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;<span class="comment">//逆序存</span></span><br><span class="line">		a[k-i<span class="number">-1</span>]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k1;++i)&#123;<span class="comment">//逆序存</span></span><br><span class="line">		b[k1-i<span class="number">-1</span>]=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-b[i]&gt;=<span class="number">0</span>) ans[i]=a[i]-b[i];<span class="comment">//如果可以减的够直接减</span></span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">//减不够借位</span></span><br><span class="line">			a[i<span class="number">+1</span>]-=<span class="number">1</span>;</span><br><span class="line">			a[i]+=<span class="number">10</span>;</span><br><span class="line">			ans[i]=a[i]-b[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(ans[k]==<span class="number">0</span>&amp;&amp;k&gt;<span class="number">1</span>) k--;<span class="comment">//处理多余前缀0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">0</span>;--i) cout&lt;&lt;ans[i];</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-高精度乘法"><a href="#3-高精度乘法" class="headerlink" title="3.高精度乘法"></a>3.高精度乘法</h3><p>图解：</p>
<p><img src="/images/image-20230804163342851.png" alt="c++算法图"></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],ans[maxn];</span><br><span class="line">string s,s1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;<span class="comment">//判断相除的俩个数是否含有0</span></span><br><span class="line">	<span class="keyword">if</span>((s.<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)||(s<span class="number">1.</span><span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;s1[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> k,k1;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;s1;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">fun</span>()) cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;<span class="comment">//有0，相乘必为0</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		k=s.<span class="built_in">size</span>();</span><br><span class="line">		k1=s<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;<span class="comment">//逆序相存</span></span><br><span class="line">			a[k-i<span class="number">-1</span>]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k1;++i)&#123;<span class="comment">//逆序相存</span></span><br><span class="line">			b[k1-i<span class="number">-1</span>]=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> idex;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k1;++j)&#123;</span><br><span class="line">				idex=i+j;<span class="comment">//对应位置</span></span><br><span class="line">				ans[idex]+=(a[i]*b[j]);</span><br><span class="line">				<span class="keyword">if</span>(ans[idex]&gt;=<span class="number">10</span>)&#123;<span class="comment">//进位</span></span><br><span class="line">					ans[idex<span class="number">+1</span>]+=ans[idex]/<span class="number">10</span>;</span><br><span class="line">					ans[idex]%=<span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> kk=k1+k;<span class="comment">//俩个数相乘的位数最多位这俩个位数相加</span></span><br><span class="line">		<span class="keyword">while</span>(ans[kk]==<span class="number">0</span>&amp;&amp;kk&gt;<span class="number">1</span>) kk--;<span class="comment">//去除多余前导0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=kk;i&gt;=<span class="number">0</span>;--i) cout&lt;&lt;ans[i];</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-高精度除法"><a href="#4-高精度除法" class="headerlink" title="4.高精度除法"></a>4.高精度除法</h3><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><h1 id="第五周笔记"><a href="#第五周笔记" class="headerlink" title="第五周笔记"></a>第五周笔记</h1><h3 id="DP主打的捏，就是一个思想而已，只有多练习题"><a href="#DP主打的捏，就是一个思想而已，只有多练习题" class="headerlink" title="DP主打的捏，就是一个思想而已，只有多练习题"></a>DP主打的捏，就是一个思想而已，只有多练习题</h3><h1 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h1><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1."></a>例题1.</h3><p><img src="/images/image-20230808145004493.png" alt="c++算法图"></p>
<h3 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="type">int</span> s[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;cin&gt;&gt;s[i];s[i]=s[i]+s[i<span class="number">-1</span>];&#125;</span><br><span class="line">    <span class="comment">//dp[i][j]  i==j时 就是长度为1的时候，不用合并区间，所以代价为0</span></span><br><span class="line">    <span class="comment">//i!=j时 k为区间间隔点 dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+s[j]-s[i-1])；表示的是i~j代价最小值=i~k代价最小值+k+1~j代价最小值再加上合并这俩堆的代价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;++len)&#123;<span class="comment">//枚举区间长度（因为长度为1，不用合并，直接最小代价为0，所以从2开始枚举）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;len+i<span class="number">-1</span>&lt;=n;++i)&#123;<span class="comment">//左端点</span></span><br><span class="line">            <span class="type">int</span> j=len+i<span class="number">-1</span>;<span class="comment">//右端点</span></span><br><span class="line">            dp[i][j]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;++k)&#123;<span class="comment">//间隔点</span></span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k<span class="number">+1</span>][j]+s[j]-s[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2."></a>例题2.</h3><p><img src="/images/image-20230808145137602.png" alt="c++算法图"></p>
<h3 id="AC代码：-1"><a href="#AC代码：-1" class="headerlink" title="AC代码："></a>AC代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e3</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">char</span> s[maxn];<span class="comment">//字符串</span></span><br><span class="line"><span class="type">int</span> val[maxn];<span class="comment">//储存最小得删除添加字符成本</span></span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];<span class="comment">//dp[i][j]表示得是i到j区间得字符串变为回文串所需得最小成本</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s<span class="number">+1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="type">char</span> c;</span><br><span class="line">		<span class="type">int</span> w,w1;<span class="comment">//添加 删除成本</span></span><br><span class="line">		cin&gt;&gt;c&gt;&gt;w&gt;&gt;w1;</span><br><span class="line">		val[c-<span class="string">&#x27;a&#x27;</span>]=<span class="built_in">min</span>(w,w1);<span class="comment">//存储得到这个字符所需最小成本</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;=m;++len)&#123;<span class="comment">//枚举区间长度</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len&lt;=m;++i)&#123;<span class="comment">//左区间</span></span><br><span class="line">			<span class="type">int</span> j=i+len;<span class="comment">//右区间</span></span><br><span class="line">			<span class="keyword">if</span>(s[i]==s[j]) dp[i][j]=dp[i<span class="number">+1</span>][j<span class="number">-1</span>];<span class="comment">//如果字母相等得话，此时得变回文最小花费维中间区间得最小花费</span></span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				dp[i][j]=<span class="built_in">min</span>(dp[i<span class="number">+1</span>][j]+val[s[i]-<span class="string">&#x27;a&#x27;</span>],dp[i][j<span class="number">-1</span>]+val[s[j]-<span class="string">&#x27;a&#x27;</span>]);<span class="comment">//不相等得话，min（要么将s[i]加到右边要么将它删除，要么将s[j]加到左边要么将它删除）</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[<span class="number">1</span>][m]&lt;&lt;endl;<span class="comment">//输出1~m变为回文所需最小成本</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="树上dp"><a href="#树上dp" class="headerlink" title="树上dp"></a>树上dp</h1><h3 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1."></a>例题1.</h3><p><img src="/images/image-20230808143459231.png" alt="c++算法图"></p>
<h3 id="AC代码：-2"><a href="#AC代码：-2" class="headerlink" title="AC代码："></a>AC代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//因为员工不想和上司一起出现，所以子选父不选，父选子不选</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">6e3</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> happy[maxn],fa[maxn];</span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">2</span>];<span class="comment">//选根结点与不选此根节点 dp[u][1]代表选根节点 dp[u][0]代表不选根节点</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];<span class="comment">//邻接表存图</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//合并</span></span><br><span class="line">	fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nint</span><span class="params">()</span></span>&#123;<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	dp[u][<span class="number">1</span>]=happy[u];<span class="comment">//选父亲节点,得到此父亲节点得happy值</span></span><br><span class="line">	<span class="type">int</span> len=a[u].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;<span class="comment">//遍历儿子节点</span></span><br><span class="line">		<span class="type">int</span> v=a[u][i];<span class="comment">//儿子结点</span></span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">1</span>],dp[v][<span class="number">0</span>]);<span class="comment">//不选父亲结点时 此时聚会Happy最大值=儿子结点选与1不选得最大值</span></span><br><span class="line">		dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];<span class="comment">//选父亲结点时 此时聚会Happy最大值=选此时父亲结点+不选此时儿子结点得值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;happy[i];</span><br><span class="line">	<span class="built_in">nint</span>();<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">		<span class="type">int</span> from,to;</span><br><span class="line">		cin&gt;&gt;to&gt;&gt;from;</span><br><span class="line">		a[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">		<span class="built_in">merge</span>(to,from);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> root;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[i]==i) &#123;root=i;<span class="keyword">break</span>;&#125;<span class="comment">//自己是自己得爸爸说明自己是根节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(root);</span><br><span class="line">	<span class="type">int</span> ans=<span class="built_in">max</span>(dp[root][<span class="number">0</span>],dp[root][<span class="number">1</span>]);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2."></a>例题2.</h3><p><img src="/images/image-20230808144224228.png" alt="c++算法图"></p>
<h3 id="AC代码：-3"><a href="#AC代码：-3" class="headerlink" title="AC代码："></a>AC代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">2e3</span>;</span><br><span class="line"><span class="type">int</span> fa[maxn],dp[maxn][<span class="number">2</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	fa[y]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nint</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	dp[u][<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//选根结点</span></span><br><span class="line">	<span class="type">int</span> len=a[u].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">		<span class="type">int</span> v=a[u][i];</span><br><span class="line">		<span class="built_in">dfs</span>(v);</span><br><span class="line">		dp[u][<span class="number">0</span>]+=dp[v][<span class="number">1</span>];<span class="comment">//根不选的话子结点必选</span></span><br><span class="line">		dp[u][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]);<span class="comment">//根选，子可选可不选</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="built_in">nint</span>();</span><br><span class="line">		<span class="type">int</span> m,from,to;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d:(%d)&quot;</span>,&amp;from,&amp;m);</span><br><span class="line">			<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">				cin&gt;&gt;to;</span><br><span class="line">				<span class="built_in">merge</span>(from,to);</span><br><span class="line">				a[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> root;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==fa[i]) &#123;root=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(root);</span><br><span class="line">		cout&lt;&lt;<span class="built_in">min</span>(dp[root][<span class="number">1</span>],dp[root][<span class="number">0</span>])&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) a[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="快速幂和矩阵快速幂"><a href="#快速幂和矩阵快速幂" class="headerlink" title="快速幂和矩阵快速幂"></a>快速幂和矩阵快速幂</h1><h2 id="一-快速幂"><a href="#一-快速幂" class="headerlink" title="一.快速幂"></a>一.快速幂</h2><h3 id="快速幂思想："><a href="#快速幂思想：" class="headerlink" title="快速幂思想："></a>快速幂思想：</h3><p>2^13&#x3D;2^(8+4+1);</p>
<p>8&#x3D;2^3    4&#x3D;2^2   1&#x3D;2^0;</p>
<p>13–&gt;二进制为1101   </p>
<h3 id="快速幂代码："><a href="#快速幂代码：" class="headerlink" title="快速幂代码："></a>快速幂代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%p;</span><br><span class="line">		a=(a*a)%p;</span><br><span class="line">		b=b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,p;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;p;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;<span class="string">&quot;^&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; mod &quot;</span>&lt;&lt;p&lt;&lt;<span class="string">&quot;=&quot;</span>;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">qmi</span>(a%p,b,p)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-龟速乘"><a href="#二-龟速乘" class="headerlink" title="二.龟速乘"></a>二.龟速乘</h2><h3 id="龟速乘的思想："><a href="#龟速乘的思想：" class="headerlink" title="龟速乘的思想："></a>龟速乘的思想：</h3><h3 id="龟速乘代码："><a href="#龟速乘代码：" class="headerlink" title="龟速乘代码："></a>龟速乘代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">guic</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans+a;</span><br><span class="line">		a=a+a;</span><br><span class="line">		b=b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;<span class="comment">//计算a*b</span></span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">guic</span>(a,b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-矩阵乘法"><a href="#三-矩阵乘法" class="headerlink" title="三.矩阵乘法"></a>三.矩阵乘法</h2><h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>矩阵乘法&#x3D;a的行*b的列的和</p>
<p><img src="/images/image-20230808173925700.png" alt="c++算法图"></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i)&#123;<span class="comment">//矩阵乘法</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;++j)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;++k)&#123;</span><br><span class="line">				c[i][j]=(c[i][j]+x[i][k]*y[k][j])%<span class="number">10000</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四-矩阵快速幂"><a href="#四-矩阵快速幂" class="headerlink" title="四.矩阵快速幂"></a>四.矩阵快速幂</h2><h3 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h3><p><img src="/images/image-20230808172419536.png" alt="c++算法图"></p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nint</span><span class="params">()</span></span>&#123;<span class="comment">//刚开始的斐波那契矩阵[1 1]</span></span><br><span class="line">    a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;<span class="comment">//               [1 0]</span></span><br><span class="line">	a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x[][<span class="number">10</span>],<span class="type">int</span> y[][<span class="number">10</span>])</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span> c);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i)&#123;<span class="comment">//矩阵乘法</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;++j)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;++k)&#123;</span><br><span class="line">				c[i][j]=(c[i][j]+x[i][k]*y[k][j])%<span class="number">10000</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;++j)&#123;</span><br><span class="line">			y[i][j]=c[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">juzhenkmi</span><span class="params">(<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	ans[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">	ans[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;++i)&#123;</span><br><span class="line">		ans[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125; <span class="comment">//初始化单位矩阵[1  0]</span></span><br><span class="line">	<span class="keyword">while</span>(b)&#123;       <span class="comment">//[0  1]</span></span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>) <span class="built_in">fun</span>(a,ans); <span class="comment">//ans=a*ans</span></span><br><span class="line">		b=b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	    <span class="built_in">fun</span>(a,a);<span class="comment">//a=a*a</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">nint</span>();</span><br><span class="line">		<span class="built_in">juzhenkmi</span>(n);</span><br><span class="line">		<span class="type">int</span> z=ans[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(z%<span class="number">10000</span>==<span class="number">0</span>) cout&lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;z%<span class="number">10000</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h1><h2 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h2><p>a*b &#x3D;n a和b都是质数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;<span class="comment">//分解质因数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(n%i))&#123;</span><br><span class="line">			<span class="keyword">while</span>(!(n%i))&#123;</span><br><span class="line">				ans++;<span class="comment">//记录幂次</span></span><br><span class="line">				n/=i;</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;<span class="comment">//本身就是一个质因子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		<span class="built_in">fun</span>(n);</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最大公约数-——gcd-x-y"><a href="#最大公约数-——gcd-x-y" class="headerlink" title="最大公约数(——gcd(x,y))"></a>最大公约数(——gcd(x,y))</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大公约数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(x%y)) <span class="keyword">return</span> y;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(y,x%y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b;</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">gcd</span>(a,b)&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;__gcd(a,b)&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>最小公倍数&#x3D;两数的乘积&#x2F;最大公约(因)数</p>
<h2 id="约数的个数"><a href="#约数的个数" class="headerlink" title="约数的个数"></a>约数的个数</h2><p>n&#x3D;p1^a1*p2^a2….（p1为n的质因子）</p>
<p>约数个数&#x3D;(a1+1)<em>(a2+1)</em>(a3+1)…..</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; ma;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(n%i))&#123;</span><br><span class="line">			<span class="keyword">while</span>(!(n%i))&#123;</span><br><span class="line">				n/=i;</span><br><span class="line">			    ma[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) ma[n]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">	    <span class="built_in">fun</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it:ma)&#123;</span><br><span class="line">		ans=ans*(it.second<span class="number">+1</span>)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h2><p>n&#x3D;p1^a1*p2^a2….（p1为n的质因子）</p>
<p>约数之和&#x3D;(p1^0+p1^1+….+p1^a1)*(p2^0+p2^1+….+p2^a2)……</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//约数之和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;</span><br><span class="line">		<span class="type">int</span> sum=i;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(!(n%i))&#123;</span><br><span class="line">			cnt+=sum;</span><br><span class="line">			sum*=i;</span><br><span class="line">			n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">		ans*=cnt;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans*=(n<span class="number">+1</span>);</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//欧拉函数求1~n中与N互质的个数</span></span><br><span class="line"><span class="comment">//n=p1^a1*p2^a2*....（p1为n的质因子）</span></span><br><span class="line"><span class="comment">//俩个数的最大公约数为1，成为互质，__gcd(a,b)=1,a与b互质</span></span><br><span class="line"><span class="comment">//与n互质个数为ans=n*(1-1/p1)*(1-1/p2)....</span></span><br><span class="line"><span class="comment">//难点在于如何分解质因数咯</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;++i)&#123;<span class="comment">//质因数分解</span></span><br><span class="line">		<span class="comment">//if(!(n%i)) ans=ans*(1-1/i);但是捏这样会有整除符号,有小数之类的,所以不妨将将ans除以一个i,后面乘以一个i</span></span><br><span class="line">		<span class="keyword">if</span>(!(n%i)) ans=ans/i*(i<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">while</span>(!(n%i))&#123;</span><br><span class="line">			n/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>) ans=ans/n*(n<span class="number">-1</span>);<span class="comment">//当它本身就是一个质数时</span></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t,n;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">fun</span>(n)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>


    </article>
    
    <div class="read-nums">
      <!-- id 将作为查询条件 -->
      <span id="2023/03/27/ACM暑假集训笔记/" class="leancloud_visitors" data-flag-title="Your Article Title">
        <em class="post-meta-item-text">浏览量</em>
        <i class="leancloud-visitors-count"></i>
      </span>
    </div>
    <div class="comments-intro">
      <h2>评论区</h2>
      <p>欢迎你留下宝贵的意见，昵称输入QQ号会显示QQ头像哦~</p>
    </div>
    <div id="vcomments" class="vcomments"></div>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E9%9F%A9%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">小韩算法笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#auto%E9%81%8D%E5%8E%86"><span class="toc-number">2.</span> <span class="toc-text">auto遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#find%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">find函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">4.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-vector-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-%E6%88%90%E5%80%8D%E5%A2%9E%E9%95%BF"><span class="toc-number">4.1.</span> <span class="toc-text">1.vector(动态数组 成倍增长)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-queue-%E9%98%9F%E5%88%97-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA"><span class="toc-number">4.2.</span> <span class="toc-text">2.queue(队列 先进先出)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-stack%EF%BC%88%E6%A0%88-%E5%85%88%E8%BF%9B%E5%90%8E%E5%87%BA%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">3.stack（栈 先进后出）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-string-string%E7%B1%BB"><span class="toc-number">4.4.</span> <span class="toc-text">4.string(string类)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9Agetline-cin-s-%E5%BF%85%E9%A1%BB%E7%94%A8%E4%BA%8Estring%E7%B1%BB%EF%BC%81%EF%BC%81%EF%BC%81%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%8F%96%E7%A9%BA%E6%A0%BC"><span class="toc-number">4.4.1.</span> <span class="toc-text">注意：getline(cin,s)必须用于string类！！！可以读取空格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-set-%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">4.5.</span> <span class="toc-text">5.set(去重排序)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-map-%E6%98%A0%E5%B0%84-%EF%BC%88%E9%94%AE%E5%80%BC-%E2%80%93-%E5%80%BC-%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">6.map(映射 （键值 –&gt;值)）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-pair-%E4%B8%80%E5%AF%B9-%E9%98%9F%E7%BB%84"><span class="toc-number">4.7.</span> <span class="toc-text">7.pair(一对&#x2F;队组)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-priority-queue-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">4.8.</span> <span class="toc-text">8.priority_queue(优先队列)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">4.9.</span> <span class="toc-text">9.双端队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-unordered-map"><span class="toc-number">4.10.</span> <span class="toc-text">10.unordered_map</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS"><span class="toc-number">5.</span> <span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dfs%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.1.</span> <span class="toc-text">dfs模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%97%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text">1.数字全排列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BFS"><span class="toc-number">6.</span> <span class="toc-text">BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS%E6%A8%A1%E6%9D%BF-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">6.1.</span> <span class="toc-text">BFS模板(优先队列)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%8E%E6%8A%98%E5%8D%8A%E6%9E%9A%E4%B8%BE"><span class="toc-number">7.</span> <span class="toc-text">二分法与折半枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8C%E5%88%86%E6%B3%95%EF%BC%88%E5%BF%85%E9%A1%BB%E4%BA%89%E5%AF%B9%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">1.二分法（必须争对有序序列）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-lower-bound-upper-bound-%EF%BC%8Cbinary-search"><span class="toc-number">7.2.</span> <span class="toc-text">一.二分查找(lower_bound(), upper_bound()，binary_search())</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%AF%8F%E6%97%A5%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">7.3.</span> <span class="toc-text">二.每日小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-sort%E9%BB%98%E8%AE%A4%E6%8E%92%E5%BA%8F%E4%B8%BAless%EF%BC%88%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%EF%BC%89%EF%BC%8C%E8%A6%81%E6%83%B3%E5%AE%9E%E7%8E%B0%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8F%EF%BC%9A"><span class="toc-number">7.3.0.0.1.</span> <span class="toc-text">1.sort默认排序为less（从小到大），要想实现从大到小：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%CE%A0-3-1416%E2%80%A6-acos-1-0"><span class="toc-number">7.3.0.0.2.</span> <span class="toc-text">2.Π&#x3D;3.1416…..&#x3D;acos(-1.0);</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89-%E4%BA%8C%E5%88%86%E6%9F%A5%E5%80%BC-%E6%9C%80%E5%A4%A7%E5%8C%96%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%8C%96%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">7.3.0.0.3.</span> <span class="toc-text">三.二分查值(最大化最小值、最小化最大值)</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">单调栈与单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">8.1.</span> <span class="toc-text">1.单调栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">8.2.</span> <span class="toc-text">2.单调队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="toc-number">9.</span> <span class="toc-text">博弈论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B7%B4%E4%BB%80%E5%8D%9A%E5%BC%88"><span class="toc-number">9.1.</span> <span class="toc-text">1.巴什博弈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%BC%88"><span class="toc-number">9.2.</span> <span class="toc-text">2.威佐夫博弈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88"><span class="toc-number">9.3.</span> <span class="toc-text">3.尼姆博弈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%8D%9A%E5%BC%88"><span class="toc-number">9.4.</span> <span class="toc-text">4.斐波那契博弈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E5%91%A8%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%9F%A5%E7%BC%BA"><span class="toc-number">10.</span> <span class="toc-text">一周小知识点查缺</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#sort-a-1-a-n-1-greater"><span class="toc-number">10.0.0.0.1.</span> <span class="toc-text">sort(a+1,a+n+1,greater&lt;int&gt;());</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%AC%94%E8%AE%B0"><span class="toc-number">11.</span> <span class="toc-text">第二周笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">12.</span> <span class="toc-text">字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%BB%BA%E6%A0%91%EF%BC%9A"><span class="toc-number">12.1.</span> <span class="toc-text">一.建树：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">12.2.</span> <span class="toc-text">二.查找：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86"><span class="toc-number">13.</span> <span class="toc-text">前缀和与差分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">13.1.</span> <span class="toc-text">一.一维前缀和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">13.2.</span> <span class="toc-text">二.二维前缀和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-sum-i-j-%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">13.2.1.</span> <span class="toc-text">1.sum[i][j]的定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%82%B9%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%88sum-i-j-%EF%BC%89"><span class="toc-number">13.2.2.</span> <span class="toc-text">2.如何构造每一个点的前缀和（sum[i][j]）?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E6%B1%82%E7%82%B9%EF%BC%88x1-y1-%E5%88%B0%EF%BC%88x2-y2-%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">13.2.3.</span> <span class="toc-text">3.如何求点（x1,y1)到（x2,y2)之间区域的前缀和呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">13.3.</span> <span class="toc-text">三.一维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84-pre-i-a-i-a-i-1"><span class="toc-number">13.3.1.</span> <span class="toc-text">1.差分数组  pre[i]&#x3D;a[i]-a[i-1];</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%81%87%E5%AE%9A%E8%A6%81%E5%9C%A8l%EF%BC%8Cr%E5%8C%BA%E9%97%B4%E9%83%BD%E5%8A%A0%E4%B8%8Ax-%E5%AF%B9%E4%BA%8E%E6%93%8D%E4%BD%9C-l-r-x-%E5%8D%B3pre-l-x-pre-r-1-x"><span class="toc-number">13.3.2.</span> <span class="toc-text">2.假定要在l，r区间都加上x,对于操作[l,r]+x;即pre[l]+x,pre[r+1]-x;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">13.4.</span> <span class="toc-text">四.二维差分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-a-%E6%95%B0%E7%BB%84%E6%98%AFb-%E6%95%B0%E7%BB%84%E7%9A%84%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%8C%E9%82%A3%E4%B9%88b-%E6%98%AFa-%E7%9A%84%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">13.4.1.</span> <span class="toc-text">1.a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%B1%E5%88%BB%E7%90%86%E8%A7%A3b%E6%95%B0%E7%BB%84%E6%98%AFa%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-number">13.4.2.</span> <span class="toc-text">2.深刻理解b数组是a数组的差分数组：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0a%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E6%8D%8F%EF%BC%9F"><span class="toc-number">13.4.3.</span> <span class="toc-text">3.那么如何构造a数组的差分数组捏？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%95%B0%E7%BB%84"><span class="toc-number">14.</span> <span class="toc-text">线段树和线段数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E6%AE%B5%E6%95%B0%E7%BB%84"><span class="toc-number">14.1.</span> <span class="toc-text">一.线段数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">14.1.1.</span> <span class="toc-text">1.思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-lowbit%E5%87%BD%E6%95%B0%EF%BC%88%E6%B1%82%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA1%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">14.1.2.</span> <span class="toc-text">2.lowbit函数（求最后一个1的位置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A2%9E%E5%8A%A0%EF%BC%9A"><span class="toc-number">14.1.3.</span> <span class="toc-text">3.增加：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9F%A5%E6%89%BE%EF%BC%9A"><span class="toc-number">14.1.4.</span> <span class="toc-text">4.查找：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">14.2.</span> <span class="toc-text">二,.线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">14.2.1.</span> <span class="toc-text">1.结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BB%BA%E6%A0%91"><span class="toc-number">14.2.2.</span> <span class="toc-text">2.建树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9F%A5%E6%89%BE"><span class="toc-number">14.2.3.</span> <span class="toc-text">3.查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9%E5%8C%BA%E9%97%B4"><span class="toc-number">14.2.4.</span> <span class="toc-text">4.单点修改区间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8C%E5%8A%A0%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">15.</span> <span class="toc-text">并查集和加权并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%9A"><span class="toc-number">15.1.</span> <span class="toc-text">一.并查集：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0%EF%BC%88%E4%B8%80%E7%82%B9%E4%B8%8D%E8%83%BD%E6%BC%8F%E6%8E%89%EF%BC%89"><span class="toc-number">15.1.1.</span> <span class="toc-text">1.初始化函数（一点不能漏掉）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E5%87%BD%E6%95%B0"><span class="toc-number">15.1.2.</span> <span class="toc-text">2.查找函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%88%E5%B9%B6%E5%87%BD%E6%95%B0"><span class="toc-number">15.1.3.</span> <span class="toc-text">3.合并函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%8A%A0%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">15.2.</span> <span class="toc-text">二.加权并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">16.</span> <span class="toc-text">哈夫曼树和哈夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">16.1.</span> <span class="toc-text">一.哈夫曼树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">16.2.</span> <span class="toc-text">1.定义：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%9D%BF%E5%AD%90%E4%BB%A3%E7%A0%81-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">16.3.</span> <span class="toc-text">2.板子代码(优先队列)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%EF%BC%88%E5%B7%A60%E5%8F%B31%EF%BC%89"><span class="toc-number">16.3.1.</span> <span class="toc-text">二.哈夫曼编码（左0右1）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">17.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-3%E7%A7%8D%E6%9E%84%E9%80%A0%E5%9B%BE%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">17.1.</span> <span class="toc-text">一.3种构造图的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5-%E9%80%82%E5%90%88%E7%A8%A0%E5%AF%86%E5%9B%BE"><span class="toc-number">17.1.0.1.</span> <span class="toc-text">1.邻接矩阵(适合稠密图)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E7%94%A8vector"><span class="toc-number">17.1.0.2.</span> <span class="toc-text">2.邻接表（用vector)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%97%A0%E6%9D%83%E5%9B%BE"><span class="toc-number">17.1.0.2.1.</span> <span class="toc-text">1.无权图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9C%89%E6%9D%83%E5%9B%BE"><span class="toc-number">17.1.0.2.2.</span> <span class="toc-text">2.有权图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F"><span class="toc-number">17.1.0.3.</span> <span class="toc-text">3.链式前向星</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A7%A3%E6%9E%90"><span class="toc-number">17.1.1.</span> <span class="toc-text">1.解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%BF%E5%AD%90"><span class="toc-number">17.1.2.</span> <span class="toc-text">2.板子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88%E5%85%A5%E5%BA%A6%E4%B8%BA0%E5%B0%86%E5%85%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">17.2.</span> <span class="toc-text">二.拓扑排序（入度为0将其排序）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">17.2.1.</span> <span class="toc-text">1.算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%BF%E5%AD%90%EF%BC%9A"><span class="toc-number">17.2.2.</span> <span class="toc-text">2.板子：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E7%8E%AF%EF%BC%88%E5%9B%9E%E8%B7%AF%EF%BC%89"><span class="toc-number">17.2.3.</span> <span class="toc-text">3.判断有向图中有没有环（回路）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">17.2.4.</span> <span class="toc-text">4.注意：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E5%91%A8%E7%AC%94%E8%AE%B0"><span class="toc-number">18.</span> <span class="toc-text">第三周笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">19.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-Floyd%E7%AE%97%E6%B3%95-%E5%8F%AF%E4%BB%A5%E6%B1%82%E4%BB%BB%E6%84%8F%E4%BF%A9%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB%EF%BC%89"><span class="toc-number">19.1.</span> <span class="toc-text">一.Floyd算法(可以求任意俩点之间的距离）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3"><span class="toc-number">19.1.1.</span> <span class="toc-text">1.思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81"><span class="toc-number">19.1.2.</span> <span class="toc-text">2.代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-Dijkstra%EF%BC%88%E6%8C%89%E7%82%B9%E6%9B%B4%E6%96%B0-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-number">19.2.</span> <span class="toc-text">二.Dijkstra（按点更新  单源最短路径）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3-1"><span class="toc-number">19.2.1.</span> <span class="toc-text">1.思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81-1"><span class="toc-number">19.2.2.</span> <span class="toc-text">2.代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-Bellman-flod"><span class="toc-number">19.3.</span> <span class="toc-text">三.Bellman-flod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3%EF%BC%9A-1"><span class="toc-number">19.3.1.</span> <span class="toc-text">1.思想：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">20.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-prim-%E6%8C%89%E7%82%B9"><span class="toc-number">20.1.</span> <span class="toc-text">一.prim(按点)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-kruskal-%E6%8C%89%E8%BE%B9%EF%BC%89"><span class="toc-number">20.2.</span> <span class="toc-text">二.kruskal(按边）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3-2"><span class="toc-number">20.2.1.</span> <span class="toc-text">1.思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%EF%BC%88P3366-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89"><span class="toc-number">20.2.2.</span> <span class="toc-text">2.代码（P3366 【模板】最小生成树）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LCA%EF%BC%88%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">21.</span> <span class="toc-text">LCA（最近公共祖先)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%9C%B4%E7%B4%A0%E6%B3%95%EF%BC%88%E4%B8%80%E6%AD%A5%E4%B8%80%E8%B7%B3%EF%BC%89"><span class="toc-number">21.1.</span> <span class="toc-text">一.朴素法（一步一跳）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3-3"><span class="toc-number">21.1.1.</span> <span class="toc-text">1.思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81-2"><span class="toc-number">21.1.2.</span> <span class="toc-text">2.代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%80%8D%E5%A2%9E%E6%B1%82Lca"><span class="toc-number">21.2.</span> <span class="toc-text">二.倍增求Lca</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3-4"><span class="toc-number">21.2.1.</span> <span class="toc-text">1.思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81-P3379-%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88LCA%EF%BC%89"><span class="toc-number">21.2.2.</span> <span class="toc-text">2.代码(P3379 【模板】最近公共祖先（LCA）)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E4%B8%8Etarjan"><span class="toc-number">22.</span> <span class="toc-text">强连通与tarjan</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%A6%82%E5%BF%B5"><span class="toc-number">22.1.</span> <span class="toc-text">一.概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">22.2.</span> <span class="toc-text">强连通分量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%80%9D%E6%83%B3"><span class="toc-number">22.3.</span> <span class="toc-text">二.思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E4%BB%A3%E7%A0%81"><span class="toc-number">22.4.</span> <span class="toc-text">三.代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98"><span class="toc-number">23.</span> <span class="toc-text">最大流问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-Dinic%E7%AE%97%E6%B3%95%EF%BC%88o-n-2-m-%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">23.1.</span> <span class="toc-text">一.Dinic算法（o(n^2*m)重点）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%AC%94%E8%AE%B0"><span class="toc-number">24.</span> <span class="toc-text">第四周笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="toc-number">25.</span> <span class="toc-text">欧拉回路</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E9%83%A8%E5%9B%BE"><span class="toc-number">26.</span> <span class="toc-text">二部图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">27.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-0-1%E8%83%8C%E5%8C%85-%E6%AF%8F%E4%BB%B6%E7%89%A9%E5%93%81%E5%8F%AA%E6%9C%891%E4%BB%B6"><span class="toc-number">27.1.</span> <span class="toc-text">一.0-1背包(每件物品只有1件)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3-5"><span class="toc-number">27.1.1.</span> <span class="toc-text">1.思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E7%BB%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">27.1.2.</span> <span class="toc-text">2.二维代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%80%E7%BB%B4%E4%BC%98%E5%8C%96%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">27.1.3.</span> <span class="toc-text">3.一维优化思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%80%E7%BB%B4%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81"><span class="toc-number">27.1.4.</span> <span class="toc-text">4.一维滚动数组代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%88%E6%AF%8F%E7%A7%8D%E7%89%A9%E5%93%81%E6%95%B0%E9%87%8F%E4%B8%BA%E6%97%A0%E9%99%90%E4%BB%B6%EF%BC%89"><span class="toc-number">27.2.</span> <span class="toc-text">二.完全背包（每种物品数量为无限件）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E6%83%B3-6"><span class="toc-number">27.2.1.</span> <span class="toc-text">1.思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81-3"><span class="toc-number">27.2.2.</span> <span class="toc-text">2.代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%88%E6%AF%8F%E7%A7%8D%E7%89%A9%E5%93%81%E6%95%B0%E9%87%8F%E6%9C%89%E9%99%90%E4%BB%B6%EF%BC%89"><span class="toc-number">27.3.</span> <span class="toc-text">三.多重背包（每种物品数量有限件）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85%EF%BC%88%E6%AF%8F%E7%BB%84%E4%B8%80%E4%BA%9B%E7%89%A9%E5%93%81%EF%BC%8C%E6%9C%80%E5%A4%9A%E5%9C%A8%E6%AF%8F%E7%BB%84%E9%87%8C%E9%9D%A2%E9%80%891%E4%BB%B6%EF%BC%89"><span class="toc-number">27.4.</span> <span class="toc-text">四.分组背包（每组一些物品，最多在每组里面选1件）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8A%A8%E8%A7%84"><span class="toc-number">28.</span> <span class="toc-text">线性动规</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-LIS%EF%BC%88%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89"><span class="toc-number">28.1.</span> <span class="toc-text">一.LIS（最长上升子序列）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">28.1.1.</span> <span class="toc-text">1.什么是子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B1%82LIS%E6%80%9D%E8%B7%AF"><span class="toc-number">28.1.2.</span> <span class="toc-text">2.求LIS思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-LCA%EF%BC%88%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89"><span class="toc-number">28.2.</span> <span class="toc-text">二.LCA（最长公共子序列）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%80%9D%E8%B7%AF"><span class="toc-number">28.2.1.</span> <span class="toc-text">1.思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81-4"><span class="toc-number">28.2.2.</span> <span class="toc-text">2.代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95%EF%BC%88%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">29.</span> <span class="toc-text">马拉车算法（最大回文字符串）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">30.</span> <span class="toc-text">KMP算法(字符串匹配问题)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-KMP%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">30.0.1.</span> <span class="toc-text">1.KMP解决的问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-KMP%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">30.0.2.</span> <span class="toc-text">2.KMP算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-KMP%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">30.0.3.</span> <span class="toc-text">3.KMP代码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">31.</span> <span class="toc-text">高精度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="toc-number">31.0.1.</span> <span class="toc-text">1.高精度加法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="toc-number">31.0.2.</span> <span class="toc-text">2.高精度减法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="toc-number">31.0.3.</span> <span class="toc-text">3.高精度乘法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="toc-number">31.0.4.</span> <span class="toc-text">4.高精度除法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AC%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">32.</span> <span class="toc-text">AC自动机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E5%91%A8%E7%AC%94%E8%AE%B0"><span class="toc-number">33.</span> <span class="toc-text">第五周笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DP%E4%B8%BB%E6%89%93%E7%9A%84%E6%8D%8F%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%80%9D%E6%83%B3%E8%80%8C%E5%B7%B2%EF%BC%8C%E5%8F%AA%E6%9C%89%E5%A4%9A%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">33.0.1.</span> <span class="toc-text">DP主打的捏，就是一个思想而已，只有多练习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4dp"><span class="toc-number">34.</span> <span class="toc-text">区间dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981"><span class="toc-number">34.0.1.</span> <span class="toc-text">例题1.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">34.0.2.</span> <span class="toc-text">AC代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982"><span class="toc-number">34.0.3.</span> <span class="toc-text">例题2.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A-1"><span class="toc-number">34.0.4.</span> <span class="toc-text">AC代码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8Adp"><span class="toc-number">35.</span> <span class="toc-text">树上dp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-1"><span class="toc-number">35.0.1.</span> <span class="toc-text">例题1.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A-2"><span class="toc-number">35.0.2.</span> <span class="toc-text">AC代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982-1"><span class="toc-number">35.0.3.</span> <span class="toc-text">例题2.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AC%E4%BB%A3%E7%A0%81%EF%BC%9A-3"><span class="toc-number">35.0.4.</span> <span class="toc-text">AC代码：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E5%92%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">36.</span> <span class="toc-text">快速幂和矩阵快速幂</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">36.1.</span> <span class="toc-text">一.快速幂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">36.1.1.</span> <span class="toc-text">快速幂思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">36.1.2.</span> <span class="toc-text">快速幂代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E9%BE%9F%E9%80%9F%E4%B9%98"><span class="toc-number">36.2.</span> <span class="toc-text">二.龟速乘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BE%9F%E9%80%9F%E4%B9%98%E7%9A%84%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">36.2.1.</span> <span class="toc-text">龟速乘的思想：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BE%9F%E9%80%9F%E4%B9%98%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">36.2.2.</span> <span class="toc-text">龟速乘代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="toc-number">36.3.</span> <span class="toc-text">三.矩阵乘法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97"><span class="toc-number">36.3.1.</span> <span class="toc-text">计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">36.3.2.</span> <span class="toc-text">代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">36.4.</span> <span class="toc-text">四.矩阵快速幂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%BE%8B%E9%A2%98"><span class="toc-number">36.4.1.</span> <span class="toc-text">模板例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AC%E4%BB%A3%E7%A0%81"><span class="toc-number">36.4.2.</span> <span class="toc-text">AC代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">37.</span> <span class="toc-text">数论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="toc-number">37.1.</span> <span class="toc-text">分解质因数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-%E2%80%94%E2%80%94gcd-x-y"><span class="toc-number">37.2.</span> <span class="toc-text">最大公约数(——gcd(x,y))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">37.3.</span> <span class="toc-text">最小公倍数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">37.4.</span> <span class="toc-text">约数的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">37.5.</span> <span class="toc-text">约数之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">37.6.</span> <span class="toc-text">欧拉函数</span></a></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/2023/10/25/数据库知识/">mysql</a>
            </p>
           
          
        </div>
      
    </div>
  </div>
</div>


<script>
  // var定义，避免pjax重新进来造成的重复声明错误
  var config = JSON.parse('{"enable":true,"appId":"Pf8zCXGEH1qsprnWfikVVujL-gzGzoHsz","appKey":"qOqoiUHhH1TGtLRUYURkLRQX","placeholder":"请留下你宝贵的意见吧~","meta":["nick"],"recordIP":true,"visitor":true,"enableQQ":true}')
  new Valine({
    el: '#vcomments',
    appId: config.appId,
    appKey: config.appKey,
    placeholder: config.placeholder,
    meta: config.meta,
    recordIP: config.recordIP,
    visitor: config.visitor,
    enableQQ: config.enableQQ,
    path: '2023/03/27/ACM暑假集训笔记/'
  })
</script>


<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const links = tocs ? tocs.querySelectorAll('a') : []
    links.forEach(link => {
      link.addEventListener('click', e => {
        const href = decodeURIComponent(e.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="main-right--content">
      Hello~大噶好。我是gcbsh，欢迎你们来到我的博客小站，希望能在这里收获到有用的东西哦！ 
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
    <div class="operate-item turn-comment hidden">
      <i class="iconfont icon-pinglun"></i>
      <span>查看评论</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>
      <p>Theme：<a target="_blank" rel="noopener" href="https://github.com/Aizener/hexo-theme-cola">Cola.</a></p>
    </div>
    <p class="main-right--refer"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">蜀ICP备2022005384号-1</a> </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const operateDom = document.querySelector('.main-right .operate-items')
    const commentDom = document.querySelector('.turn-comment')
    const cateloguDom = document.querySelector('.article-catelogue > .article-catelogue--wrapper');

    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
        const newDom = operateDom.cloneNode(true);
        const _backtopDom = newDom.querySelector('.backtop');
        const _commentDom = newDom.querySelector('.turn-comment');
        _backtopDom.addEventListener('click', () => backTopEvent());
        _commentDom.addEventListener('click', () => commentDomEvent());
        cateloguDom.appendChild(newDom);
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"去有风的地方","artist":"郁可唯","url":"music/quyoufengdedifang.mp3","cover":"/imgs/quyoufengdedifang.jpg"},{"name":"消失","artist":"苏运莹","url":"music/xiaoshi.mp3","cover":"/imgs/xiaoshi.jpg"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    backTopEvent();
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    commentDomEvent();
  })

  function backTopEvent() {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  function commentDomEvent() {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  }
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>
  <div id="gray" class="gray"></div>

  <script>
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }

    const rootPath = "/"

    const checkAndSetArticlePageLayout = () => {
      const path = location.pathname.replace(rootPath, '');
      if (
        /^\/?\d{4}\/\d{2}\/\d{2}\/.*/.test(path) ||
        /^log\/.+/.test(path)
      ) {
        $('.main-container, .main-right, .main-right-wrapper').addClass('is-article')
      } else {
        $('.main-container, .main-right, .main-right-wrapper').removeClass('is-article')
      }
    }

    const gray = "none"
    const setGrayStyle = () => {
      if (gray === 'none') {
        return
      } else if (gray === 'index') {
        location.pathname === '/' ? $('#gray').show() : $('#gray').hide()
      } else if (gray === 'all') {
        $('#gray').show()
      }
    }
    setGrayStyle()


    window.onload = function () {
      checkAndSetArticlePageLayout()
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll();
        }, 500)
      }, 500)
    }
    
    let status = 0
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {
      container: '#main-container',
      fragment: '#main-container',
      timeout: 8000
    })

    $(document).on('pjax:start', function() {
    })
    $(document).on('pjax:complete', function() {
      status = 0
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
      setGrayStyle()
      checkAndSetArticlePageLayout()
    })
    $(document).on('pjax:popstate', function() {
      status = -1
      checkAndSetArticlePageLayout()
    });
  </script>
</body>
</html>